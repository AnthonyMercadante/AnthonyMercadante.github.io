{"ast":null,"code":"var _jsxFileName = \"/Users/raethexn/Documents/GitHub/AnthonyMercadante.github.io/src/pages/BattleShipBot/BattleShipBot.tsx\",\n  _s = $RefreshSig$();\nimport React from 'react';\nimport { Box, Typography, IconButton, Grid, Button } from '@mui/material';\nimport ArrowBackIcon from '@mui/icons-material/ArrowBack';\nimport LandscapeOverlay from '../../components/LandscapeOverlay';\nimport { useNavigate } from 'react-router-dom';\nimport Starfield from '../../components/Starfield';\nimport FileTreeItem from '../../components/FileTreeItem';\nimport GetAppIcon from '@mui/icons-material/GetApp';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst style = {\n  container: {\n    padding: '3rem',\n    backgroundColor: 'rgba(0, 0, 0, 0.9)',\n    color: '#E0E0E0',\n    minHeight: '100vh',\n    display: 'flex',\n    flexDirection: 'column',\n    alignItems: 'center',\n    justifyContent: 'center',\n    maxWidth: '900px',\n    marginLeft: 'auto',\n    marginRight: 'auto',\n    borderRadius: '12px',\n    '@media (max-width: 600px)': {\n      maxWidth: '100%',\n      padding: '1rem'\n    }\n  },\n  header: {\n    marginBottom: '2rem',\n    textAlign: 'center',\n    fontSize: '2rem',\n    color: '#FFFFFF'\n  },\n  paragraph: {\n    marginBottom: '1rem',\n    textAlign: 'left',\n    lineHeight: '1.6'\n  },\n  featureBox: {\n    marginTop: '4rem',\n    textAlign: 'left'\n  },\n  featureHeading: {\n    marginBottom: '1rem',\n    fontSize: '1.5rem',\n    fontWeight: 'bold',\n    color: '#FFFFFF'\n  },\n  backButton: {\n    position: 'absolute',\n    top: '20px',\n    left: '20px',\n    zIndex: 1\n  },\n  codeSnippet: {\n    backgroundColor: '#333',\n    color: '#ddd',\n    padding: '1rem',\n    borderRadius: '8px',\n    fontSize: '.1rem'\n  },\n  link: {\n    color: '#0a84ff',\n    textDecoration: 'none',\n    '&:hover': {\n      textDecoration: 'underline'\n    }\n  }\n};\nconst filesData = [{\n  name: \"BattleShip\",\n  code: `import BattleShipAPI.BattleShipAPI;\n        public class BattleShip {\n            public static void main(String[] args) {\n        \n        \n                final int NUMBEROFGAMES = 10000;\n                System.out.println(BattleShipAPI.getVersion());\n                BattleShipAPI battleShip = new BattleShipAPI(NUMBEROFGAMES, new BattleShipAI());\n                int [] gameResults = battleShip.run();\n        \n                battleShip.reportResults();\n            }\n        }`\n}, {\n  name: \"BattleShipAI\",\n  code: `import BattleShipAPI.*;\n\n        import java.awt.Point;\n        import java.util.*;\n        \n        /**\n         * BattleShipAI is an implementation of a Battleship game bot.\n         * It uses a combination of probabilistic and targeted strategies\n         * to play Battleship against an opponent.\n         *\n         * @author - Anthony Mercadante\n         * Notes:\n         */\n        public class BattleShipAI implements BattleShipBot {\n            private int gameSize;  // Size of the game board (number of cells in one dimension)\n            private BattleShipAPI battleShip;  // Instance of the battleship game interface\n            private Random random;  // Random number generator for making random decisions\n            private CellState[][] board;  // Representation of the game board's current state\n            private boolean targetMode;  // Flag to indicate whether the bot is in target mode (targeting a specific ship)\n            private Point lastHit;  // The last successful hit coordinate\n            private Map<Point, Double> probabilityMap;  // Map to hold the probability of each cell containing a ship\n            private int[] initialShipSizes;  // Array holding the initial sizes of the ships\n            private Set<Integer> sunkShipSizes;  // Set of sizes of ships that have been sunk\n            private final List<Point> hitList = new ArrayList<>();  // List of points where the bot has successfully hit ships\n            private Boolean shipOrientation;  // Current assumption of the target ship's orientation (null if unknown)\n            private boolean[][] impossibleCells;  // Grid to mark cells where ships cannot possibly be located\n            private boolean[][] potentialCells;  // Grid to mark cells with potential to have ships based on game logic\n            private Map<Point, Set<Point>> shipGraph;  // Graph representing connections between hit cells on a ship\n            private PriorityQueue<CellProbability> probabilityQueue;  // Priority queue to manage cells based on their hit probability\n            private int[][] shipPlacementFrequency;  // Grid to track the frequency of ship placement in each cell across games\n        \n        \n            /**\n             * Initializes the TitanBot with the given BattleShip2 game instance.\n             * This method sets up the initial game state, including the game board,\n             * probability structures, and other strategic elements.\n             *\n             * @param b The BattleShip2 game instance that this bot will be playing.\n             */\n            @Override\n            public void initialize(BattleShipAPI b) {\n                battleShip = b;  // Sets the current BattleShip2 instance\n                gameSize = BattleShipAPI.BOARD_SIZE;  // Initializes the size of the game board\n                random = new Random(0xAAAAAAAA);  // Initializes the random number generator with a seed\n        \n                // Initialize the board state to empty\n                board = new CellState[gameSize][gameSize];\n                for (int i = 0; i < gameSize; i++) {\n                    for (int j = 0; j < gameSize; j++) {\n                        board[i][j] = CellState.Empty;\n                    }\n                }\n        \n                probabilityMap = new HashMap<>();  // Initializes the map for storing cell probabilities\n                sunkShipSizes = new HashSet<>();   // Initializes the set to track sizes of sunk ships\n        \n                // Initialize other strategic elements\n                targetMode = false;  // Initially not in target mode\n                lastHit = null;  // No last hit at the start\n                initialShipSizes = b.getShipSizes();  // Stores the initial sizes of the ships in the game\n                impossibleCells = new boolean[gameSize][gameSize];  // Grid to mark cells where ships cannot be located\n                potentialCells = new boolean[gameSize][gameSize];  // Grid to mark potential cells for ships\n                probabilityQueue = new PriorityQueue<>();  // Priority queue for managing cells based on probability\n                shipGraph = new HashMap<>();  // Graph to connect hits on the same ship\n                shipPlacementFrequency = new int[gameSize][gameSize]; // Tracks ship placement frequency across games\n            }\n        \n        \n        \n            /**\n             * Executes a firing action in the Battleship game.\n             * This method decides the next shot based on the current game state,\n             * utilizing different strategies depending on whether it's early in the game,\n             * in target mode (focusing on a specific ship), or otherwise.\n             * It updates the game state based on the shot's outcome.\n             */\n            @Override\n            public void fireShot() {\n                // Update the status of sunk ships and the probability map for the board\n                updateSunkShips();\n                updateProbabilityMap();\n        \n                Point shot;\n        \n                // Determine the next shot based on game phase and mode\n                if (isEarlyGame()) {\n                    // Use a probabilistic approach in the early game, considering historical data\n                    shot = getNextProbabilisticShot();\n                } else if (targetMode) {\n                    // In target mode, focus on sinking the currently targeted ship\n                    shot = getNextTargetShot();\n                } else {\n                    // Default to a targeted shot strategy outside early game and not in target mode\n                    shot = getTargetedShot();\n                }\n        \n                // Fire the shot and update the board state based on the result\n                boolean hit = battleShip.shoot(shot);\n                board[shot.x][shot.y] = hit ? CellState.Hit : CellState.Miss;\n        \n                // Handle the outcome of the shot\n                if (hit) {\n                    // If a hit, add to hit list, update target mode and related strategies\n                    hitList.add(shot);\n                    lastHit = shot;\n                    targetMode = true;\n                    updateTargetMode();\n                    updateShipGraph(shot);\n                } else if (targetMode && shipOrientation != null) {\n                    // Reset target mode if in target mode but the shot was a miss\n                    resetTargetMode();\n                }\n        \n                // If any ships were sunk, update probability and reset target mode\n                if (battleShip.numberOfShipsSunk() > 0) {\n                    updateProbabilityAfterSinking();\n                    resetTargetMode();\n                }\n            }\n        \n        \n            /**\n             * Returns the author information of this BattleShipAI class.\n             * This method is used to identify the creator of the bot.\n             *\n             * @return A string containing the name of the author and their designation.\n             */\n            @Override\n            public String getAuthors() {\n                return \"Anthony Mercadante (Software Development Student)\";\n            }\n        \n        \n        \n            /**\n             * Determines the next shot using a probabilistic approach based on the frequency of ship placements.\n             * This method iterates over the game board and selects the cell with the highest frequency of having a ship\n             * based on historical data. If no such cell is found, it defaults to a random shot.\n             *\n             * @return The point (coordinates) on the board where the next shot is to be fired.\n             */\n            private Point getNextProbabilisticShot() {\n                // Use shipPlacementFrequency to adjust your shot selection\n                Point selectedShot = null;\n                int maxFrequency = 0;\n                for (int x = 0; x < gameSize; x++) {\n                    for (int y = 0; y < gameSize; y++) {\n                        if (board[x][y] == CellState.Empty && shipPlacementFrequency[x][y] > maxFrequency) {\n                            maxFrequency = shipPlacementFrequency[x][y];\n                            selectedShot = new Point(x, y);\n                        }\n                    }\n                }\n                // Returns the most probable shot; if none is found, defaults to a random shot\n                return selectedShot != null ? selectedShot : randomShot();\n            }\n        \n        \n        \n            /**\n             * Updates the ship graph based on the latest hit.\n             * This method adds the hit point to the ship graph and establishes connections to adjacent hits,\n             * effectively mapping the parts of a ship that have been hit. This graph aids in tracking the hit\n             * sections of ships and determining their orientation.\n             *\n             * @param hit The point on the board where the latest hit occurred.\n             */\n            private void updateShipGraph(Point hit) {\n                // Add the hit point to the graph with an empty set of connections if not already present\n                shipGraph.putIfAbsent(hit, new HashSet<>());\n        \n                // Directions to check for adjacent hits: Up, Down, Left, Right\n                int[][] directions = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};\n        \n                for (int[] dir : directions) {\n                    int adjacentRow = hit.x + dir[0];\n                    int adjacentCol = hit.y + dir[1];\n                    Point adjacentPoint = new Point(adjacentRow, adjacentCol);\n        \n                    // Check if the adjacent cell is a hit and within the board bounds\n                    if (isValidCoordinate(adjacentRow, adjacentCol) && board[adjacentRow][adjacentCol] == CellState.Hit) {\n                        // Connect the current hit with the adjacent hit in the graph\n                        shipGraph.get(hit).add(adjacentPoint);\n        \n                        // Also connect the adjacent hit with the current hit\n                        shipGraph.putIfAbsent(adjacentPoint, new HashSet<>());\n                        shipGraph.get(adjacentPoint).add(hit);\n                    }\n                }\n            }\n        \n        \n            /**\n             * Checks if the given row and column coordinates are valid within the game board.\n             * A coordinate is considered valid if it lies within the bounds of the game board,\n             * which is determined by the gameSize.\n             *\n             * @param row The row coordinate to be checked.\n             * @param col The column coordinate to be checked.\n             * @return true if the coordinate is within the game board; false otherwise.\n             */\n            private boolean isValidCoordinate(int row, int col) {\n                // Check if both row and column are within the bounds of the game board\n                return row >= 0 && row < gameSize && col >= 0 && col < gameSize;\n            }\n        \n        \n        \n            /**\n             * Updates the record of sunk ships based on the current state of the game.\n             * This method compares the initial ship sizes with the current ship sizes\n             * reported by the game. If a ship size from the initial list is no longer\n             * present in the current game state, it is marked as sunk.\n             */\n            private void updateSunkShips() {\n                // Fetch the current sizes of ships remaining in the game\n                int[] currentShipSizes = battleShip.getShipSizes();\n        \n                // Iterate through the initial sizes of ships\n                for (int size : initialShipSizes) {\n                    // If a size from the initial list is not in the current list, it's sunk\n                    if (arrayDoesNotContain(currentShipSizes, size)) {\n                        sunkShipSizes.add(size);  // Mark the ship size as sunk\n                    }\n                }\n            }\n        \n        \n            /**\n             * Checks if the provided array does not contain the specified value.\n             * This utility method iterates through the array and compares each element\n             * to the given value. It is primarily used to determine if a ship of a certain size\n             * has been sunk by checking against the current array of ship sizes.\n             *\n             * @param array The array of integers to be checked.\n             * @param value The value to check for in the array.\n             * @return true if the value is not found in the array; false otherwise.\n             */\n            private boolean arrayDoesNotContain(int[] array, int value) {\n                // Iterate through each element in the array\n                for (int i : array) {\n                    // If the current element equals the value, return false (value is found)\n                    if (i == value) {\n                        return false;\n                    }\n                }\n                // Return true if the value is not found in the array\n                return true;\n            }\n        \n        \n        \n            /**\n             * Determines the next shot in target mode, focusing on sinking a specific ship.\n             * This method first updates the ship's orientation based on recent hits. If the orientation\n             * is known, it attempts to get the next shot inline with the identified orientation. If the orientation\n             * is unknown or the next inline shot is not valid, it selects a high-probability shot around the last hit.\n             * As a fallback, it resorts to a random shot if no suitable target is identified.\n             *\n             * @return The point (coordinates) on the board where the next shot is to be fired.\n             */\n            private Point getNextTargetShot() {\n                // Update the orientation of the target ship based on recent hits\n                updateShipOrientationBasedOnHits();\n        \n                // Attempt to get the next shot inline with the ship's orientation, if known\n                Point nextShot = (shipOrientation != null) ? getNextShotInLineBasedOnOrientation() : null;\n        \n                // If inline shot is not valid or orientation is unknown, prioritize high-probability cells around the last hit\n                if (nextShot == null || !isValidShot(nextShot)) {\n                    nextShot = getHighProbabilityShotAroundLastHit();\n                }\n        \n                // Fallback to a random shot if no suitable shot is identified\n                return (nextShot != null && isValidShot(nextShot)) ? nextShot : randomShot();\n            }\n        \n        \n            /**\n             * Selects the high probability shot around the last hit point.\n             * This method identifies potential target points adjacent to the last hit and\n             * evaluates their probability of containing a ship. The method selects the point\n             * with the highest probability as the next shot, considering only valid shots.\n             * It is used when the bot is in target mode and looking to efficiently sink a ship.\n             *\n             * @return The point with the highest probability around the last hit, or null if no valid targets are found.\n             */\n            private Point getHighProbabilityShotAroundLastHit() {\n                // Return null if there hasn't been a hit yet\n                if (lastHit == null) return null;\n        \n                // Get a list of points adjacent to the last hit\n                List<Point> potentialTargets = getAdjacentPoints(lastHit);\n                double maxProbability = 0.0;\n                Point bestShot = null;\n        \n                // Iterate through potential targets to find the one with the highest probability\n                for (Point target : potentialTargets) {\n                    double prob = probabilityMap.getOrDefault(target, 0.0);\n                    // Update the best shot if the current target has a higher probability and is a valid shot\n                    if (prob > maxProbability && isValidShot(target)) {\n                        maxProbability = prob;\n                        bestShot = target;\n                    }\n                }\n        \n                // Return the point with the highest probability as the best shot\n                return bestShot;\n            }\n        \n        \n            /**\n             * Retrieves a list of points adjacent to a given point on the game board.\n             * This method calculates the points that are directly up, down, left, and right\n             * of the provided point, considering only valid coordinates within the game board.\n             * It's utilized in strategies that require knowledge of surrounding cells, such as\n             * determining potential next shots around a hit.\n             *\n             * @param p The point for which adjacent points are to be found.\n             * @return A list of points adjacent to the given point, filtered for valid game board coordinates.\n             */\n            private List<Point> getAdjacentPoints(Point p) {\n                List<Point> adjacentPoints = new ArrayList<>();\n                // Array defining the four directions: Up, Down, Left, Right\n                int[][] directions = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};\n        \n                // Iterate through each direction to find adjacent points\n                for (int[] dir : directions) {\n                    int newRow = p.x + dir[0];\n                    int newCol = p.y + dir[1];\n        \n                    // Add the point to the list if it is a valid coordinate on the board\n                    if (isValidCoordinate(newRow, newCol)) {\n                        adjacentPoints.add(new Point(newRow, newCol));\n                    }\n                }\n        \n                // Return the list of adjacent, valid points\n                return adjacentPoints;\n            }\n        \n        \n        \n            /**\n             * Updates the assumed orientation of the currently targeted ship based on the list of hits.\n             * This method analyzes the hit points recorded in the hitList to determine if the ship is placed\n             * horizontally or vertically. The orientation is set to horizontal if all hits are in the same row,\n             * vertical if they are in the same column, and remains unclear (null) if the hits do not align\n             * either horizontally or vertically.\n             */\n            private void updateShipOrientationBasedOnHits() {\n                // If there are less than two hits, orientation cannot be determined\n                if (hitList.size() < 2) {\n                    shipOrientation = null;\n                    return;\n                }\n        \n                boolean isHorizontal = true;\n                boolean isVertical = true;\n                // Take the coordinates of the first hit as reference points\n                int firstRow = hitList.get(0).x;\n                int firstCol = hitList.get(0).y;\n        \n                // Iterate through the hitList to determine the ship's orientation\n                for (Point hit : hitList) {\n                    if (hit.x != firstRow) {\n                        isVertical = false;  // Different rows imply it's not vertical\n                    }\n                    if (hit.y != firstCol) {\n                        isHorizontal = false; // Different columns imply it's not horizontal\n                    }\n                }\n        \n                // Set the shipOrientation based on the findings\n                if (isHorizontal && !isVertical) {\n                    shipOrientation = true; // The ship is oriented horizontally\n                } else if (!isHorizontal && isVertical) {\n                    shipOrientation = false; // The ship is oriented vertically\n                } else {\n                    shipOrientation = null; // Orientation remains unclear\n                }\n            }\n        \n        \n            /**\n             * Determines the next shot based on the assumed orientation of the targeted ship.\n             * This method calculates the next shot point either to the right or left of the last hit\n             * for a horizontally oriented ship, or above or below the last hit for a vertically oriented ship.\n             * The method only considers valid shots within the game board bounds.\n             *\n             * @return The next shot point based on the ship's orientation, or null if no valid shot is found.\n             */\n            private Point getNextShotInLineBasedOnOrientation() {\n                // Return null if orientation is unknown or there are no hits to base the decision on\n                if (shipOrientation == null || hitList.isEmpty()) {\n                    return null;\n                }\n        \n                // Get the first and last hit points from the hit list\n                Point firstHit = hitList.get(0);\n                Point lastHit = hitList.get(hitList.size() - 1);\n        \n                if (shipOrientation) {\n                    // If the ship is oriented horizontally, check for shots to the right and left\n                    Point shotRight = new Point(lastHit.x, lastHit.y + 1);\n                    if (isValidShot(shotRight)) {\n                        return shotRight;\n                    }\n        \n                    Point shotLeft = new Point(firstHit.x, firstHit.y - 1);\n                    if (isValidShot(shotLeft)) {\n                        return shotLeft;\n                    }\n                } else {\n                    // If the ship is oriented vertically, check for shots above and below\n                    Point shotDown = new Point(lastHit.x + 1, lastHit.y);\n                    if (isValidShot(shotDown)) {\n                        return shotDown;\n                    }\n        \n                    Point shotUp = new Point(firstHit.x - 1, firstHit.y);\n                    if (isValidShot(shotUp)) {\n                        return shotUp;\n                    }\n                }\n        \n                // Return null if no valid shot is found based on the ship's orientation\n                return null;\n            }\n        \n        \n        \n            /**\n             * Checks if a given shot is valid on the game board.\n             * This method verifies that the shot is within the boundaries of the game board\n             * and targets a cell that has not been shot at yet (i.e., the cell is in an 'Empty' state).\n             * It is used to ensure that the bots shot selections are valid and executable within the game.\n             *\n             * @param p The point representing the coordinates of the shot to be validated.\n             * @return true if the shot is valid (within the game board and targeting an empty cell); false otherwise.\n             */\n            private boolean isValidShot(Point p) {\n                // Check if the point is within the game board and targets an empty cell\n                return p.x >= 0 && p.x < gameSize && p.y >= 0 && p.y < gameSize && board[p.x][p.y] == CellState.Empty;\n            }\n        \n        \n        \n            /**\n             * Updates the probability map for the entire game board.\n             * This method resets the current probabilities and recalculates them for each cell\n             * based on the potential presence of unsunk ships. It considers the sizes of the ships\n             * that are still in play and updates the probabilities for each cell being part of an unsunk ship.\n             * The method is crucial for the bots decision-making process, as it guides the shot selection\n             * by identifying the most probable locations of the remaining enemy ships.\n             */\n            private void updateProbabilityMap() {\n                // Reset the probability map to zero for all points\n                probabilityMap.replaceAll((p, v) -> 0.0);\n        \n                // Iterate through all ship sizes still in play\n                for (int shipSize : battleShip.getShipSizes()) {\n                    // Skip updating probabilities for sunk ship sizes\n                    if (!sunkShipSizes.contains(shipSize)) {\n                        // Update probabilities for each cell on the board\n                        for (Point point : probabilityMap.keySet()) {\n                            // Only update probabilities for empty cells\n                            if (board[point.x][point.y] == CellState.Empty) {\n                                // Calculate the probability for the current cell and ship size\n                                double prob = calculateProbabilityForShipSize(point.x, point.y, shipSize);\n                                // Update the probability map with the new calculated probability\n                                probabilityMap.put(point, probabilityMap.get(point) + prob);\n                            }\n                        }\n                    }\n                }\n            }\n        \n        \n        \n            /**\n             * Calculates the probability of a ship of a given size being placed horizontally at a specified location.\n             * This method iterates through each cell starting from the specified row and column, extending horizontally\n             * for the length of the ship. It checks if the placement is possible (not marked as impossible) and calculates\n             * the probability based on the size of the game board. If any part of the ship placement is marked as impossible,\n             * the probability is set to zero.\n             *\n             * @param row The starting row coordinate for the potential ship placement.\n             * @param col The starting column coordinate for the potential ship placement.\n             * @param shipSize The size of the ship to be placed.\n             * @return The probability of being able to place the ship at the specified location horizontally.\n             */\n            private double calculateHorizontalProbability(int row, int col, int shipSize) {\n                double prob = 1.0;  // Initialize probability\n        \n                // Iterate through each cell horizontally from the starting point for the length of the ship\n                for (int i = 0; i < shipSize; i++) {\n                    // Check if the cell is marked as impossible for ship placement\n                    if (impossibleCells[row][col + i]) {\n                        return 0.0;  // Return zero probability if any part of the placement is impossible\n                    }\n                    // Multiply the probability by a factor (adjust this based on game logic and board size)\n                    prob *= (1.0 / (gameSize * gameSize));\n                }\n        \n                return prob;  // Return the calculated probability\n            }\n        \n        \n            /**\n             * Calculates the probability of a ship of a given size being placed vertically at a specified location.\n             * This method iterates through each cell starting from the specified row and column, extending vertically\n             * for the length of the ship. It assesses whether placement is feasible (not in an impossible cell) and\n             * calculates the probability based on the size of the game board. If any part of the ship placement is marked\n             * as impossible, the probability is set to zero.\n             *\n             * @param row The starting row coordinate for the potential ship placement.\n             * @param col The starting column coordinate for the potential ship placement.\n             * @param shipSize The size of the ship to be placed.\n             * @return The probability of being able to place the ship at the specified location vertically.\n             */\n            private double calculateVerticalProbability(int row, int col, int shipSize) {\n                double prob = 1.0;  // Initialize probability\n        \n                // Iterate through each cell vertically from the starting point for the length of the ship\n                for (int i = 0; i < shipSize; i++) {\n                    // Check if the cell is marked as impossible for ship placement\n                    if (impossibleCells[row + i][col]) {\n                        return 0.0;  // Return zero probability if any part of the placement is impossible\n                    }\n                    // Multiply the probability by a factor (adjust this based on game logic and board size)\n                    prob *= (1.0 / (gameSize * gameSize));\n                }\n        \n                return prob;  // Return the calculated probability\n            }\n        \n        \n        \n            /**\n             * Determines whether a ship of a given size can be placed horizontally at a specified location.\n             * This method checks if the ship can fit horizontally starting from the specified row and column,\n             * ensuring that it doesn't extend beyond the game board's boundaries. It also verifies that each\n             * cell along the ship's length is empty and not marked as an impossible location for ship placement.\n             *\n             * @param row The row coordinate for the starting point of the ship placement.\n             * @param col The column coordinate for the starting point of the ship placement.\n             * @param shipSize The size of the ship to be placed.\n             * @return true if the ship can be placed horizontally at the specified location; false otherwise.\n             */\n            private boolean canPlaceShipHorizontally(int row, int col, int shipSize) {\n                // Check if the ship extends beyond the game board's boundaries\n                if (col + shipSize > gameSize) return false;\n        \n                // Iterate through each cell where the ship would be placed\n                for (int i = 0; i < shipSize; i++) {\n                    // Check if each cell is empty and not marked as impossible for ship placement\n                    if (board[row][col + i] != CellState.Empty || impossibleCells[row][col + i]) {\n                        return false;  // Return false if any cell is occupied or impossible\n                    }\n                }\n        \n                return true;  // Return true if the ship can be placed horizontally\n            }\n        \n        \n            /**\n             * Determines whether a ship of a given size can be placed vertically at a specified location.\n             * This method checks if the ship can fit vertically starting from the specified row and column,\n             * ensuring that it doesn't extend beyond the game board's boundaries. It also verifies that each\n             * cell along the ship's length is empty and not marked as an impossible location for ship placement.\n             *\n             * @param row The row coordinate for the starting point of the ship placement.\n             * @param col The column coordinate for the starting point of the ship placement.\n             * @param shipSize The size of the ship to be placed.\n             * @return true if the ship can be placed vertically at the specified location; false otherwise.\n             */\n            private boolean canPlaceShipVertically(int row, int col, int shipSize) {\n                // Check if the ship extends beyond the game board's boundaries\n                if (row + shipSize > gameSize) return false;\n        \n                // Iterate through each cell where the ship would be placed\n                for (int i = 0; i < shipSize; i++) {\n                    // Check if each cell is empty and not marked as impossible for ship placement\n                    if (board[row + i][col] != CellState.Empty || impossibleCells[row + i][col]) {\n                        return false;  // Return false if any cell is occupied or impossible\n                    }\n                }\n        \n                return true;  // Return true if the ship can be placed vertically\n            }\n        \n        \n        \n            /**\n             * Rebuilds the priority queue based on the current probability map.\n             * This method clears the existing probability queue and repopulates it with the points\n             * from the probability map, considering only those points that are still empty on the board.\n             * Each point is added along with its associated probability value. The priority queue is\n             * used for efficient selection of the next shot based on the calculated probabilities.\n             */\n            private void rebuildProbabilityQueue() {\n                // Clear the existing probability queue\n                probabilityQueue.clear();\n        \n                // Iterate through each entry in the probability map\n                for (Map.Entry<Point, Double> entry : probabilityMap.entrySet()) {\n                    Point point = entry.getKey();\n                    // Only add points to the queue that are empty on the board\n                    if (board[point.x][point.y] == CellState.Empty) {\n                        // Add the point and its probability to the queue\n                        probabilityQueue.add(new CellProbability(point, entry.getValue()));\n                    }\n                }\n            }\n        \n        \n        \n            /**\n             * Generates a random shot within the bounds of the game board.\n             * This method selects a random point on the board, ensuring that the chosen cell\n             * is empty (i.e., it has not been shot at yet). It continues to select random points\n             * until an empty cell is found, thereby guaranteeing a valid shot.\n             *\n             * @return A Point object representing the coordinates of the randomly selected shot.\n             */\n            private Point randomShot() {\n                Point shot;\n                // Continuously generate random points until an empty cell is found\n                do {\n                    // Create a point with random coordinates within the game board\n                    shot = new Point(random.nextInt(gameSize), random.nextInt(gameSize));\n                } while (board[shot.x][shot.y] != CellState.Empty);  // Ensure the cell is empty\n        \n                return shot;  // Return the valid random shot\n            }\n        \n        \n            /**\n             * Resets the targeting mode to its initial state.\n             * This method is called when the bot needs to exit target mode, typically after sinking a ship\n             * or when it needs to reevaluate its strategy. It resets various attributes related to target mode,\n             * including disabling the mode, clearing the last hit point, clearing the list of hit points, and\n             * resetting the assumed orientation of the targeted ship.\n             */\n            private void resetTargetMode() {\n                targetMode = false;          // Disable target mode\n                lastHit = null;              // Clear the last hit point\n                hitList.clear();             // Clear the list of hit points\n                shipOrientation = null;      // Reset the assumed ship orientation\n            }\n        \n        \n            /**\n             * Updates the target mode by reassessing the ship's orientation based on the hit list.\n             * This method is invoked when there are multiple hits in the hit list to determine\n             * the orientation of the ship being targeted. It sets the shipOrientation attribute\n             * based on the alignment of the first two hits: horizontal if they are in the same row,\n             * or vertical if they are in the same column.\n             */\n            private void updateTargetMode() {\n                // Check if there are at least two hits to determine the orientation\n                if (!hitList.isEmpty() && hitList.size() > 1) {\n                    Point firstHit = hitList.get(0);  // Get the first hit point\n                    Point secondHit = hitList.get(1); // Get the second hit point\n        \n                    // Determine the orientation: true for horizontal, false for vertical\n                    shipOrientation = (firstHit.x == secondHit.x);\n                }\n            }\n        \n        \n            /**\n             * Updates the probability map after a ship has been sunk.\n             * This method iterates over each point in the hit list (which represents parts of the sunk ship)\n             * and marks adjacent cells as impossible locations for other ships. It also adjusts the probabilities\n             * for cells around the sunk ship, reflecting the updated game state where no other ship can occupy\n             * those adjacent cells. This is essential for refining the probability map based on known ship placements.\n             */\n            private void updateProbabilityAfterSinking() {\n                // Iterate over each part of the sunk ship\n                for (Point sunkShipPart : hitList) {\n                    // Mark cells adjacent to each part of the sunk ship as impossible for ship placement\n                    markAdjacentAsImpossible(sunkShipPart.x, sunkShipPart.y);\n        \n                    // Adjust probability for cells around each part of the sunk ship\n                    updateAdjacentProbabilities(sunkShipPart.x, sunkShipPart.y);\n                }\n            }\n        \n        \n            /**\n             * Updates the probabilities of cells adjacent to a given coordinate on the game board.\n             * This method is used following events that change the game state, such as sinking a ship,\n             * to adjust the probabilities of nearby cells. It calculates new probabilities for cells in all\n             * four cardinal directions (up, down, left, right) adjacent to the specified cell, provided they\n             * are within the game board's boundaries and are empty.\n             *\n             * @param row The row coordinate of the central point from which to update adjacent probabilities.\n             * @param col The column coordinate of the central point from which to update adjacent probabilities.\n             */\n            private void updateAdjacentProbabilities(int row, int col) {\n                // Define the four cardinal directions\n                int[][] directions = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\n        \n                // Iterate through each direction to update adjacent cell probabilities\n                for (int[] dir : directions) {\n                    int newRow = row + dir[0];\n                    int newCol = col + dir[1];\n                    Point adjacentPoint = new Point(newRow, newCol);\n        \n                    // Check if the adjacent cell is within the game board and is empty\n                    if (isValidCoordinate(newRow, newCol) && board[newRow][newCol] == CellState.Empty) {\n                        // Calculate and update the probability for the adjacent cell\n                        double newProbability = calculateCellProbability(newRow, newCol);\n                        probabilityMap.put(adjacentPoint, newProbability);\n                    }\n                }\n            }\n        \n        \n        \n            /**\n             * Marks cells adjacent to a given coordinate as impossible locations for ship placement.\n             * This method is typically used after a ship has been sunk to mark the surrounding cells,\n             * which cannot contain any part of another ship. It assesses cells in all four cardinal\n             * directions (up, down, left, right) adjacent to the specified cell and marks them as impossible\n             * if they are within the game board's boundaries.\n             *\n             * @param row The row coordinate of the central point from which to mark adjacent cells.\n             * @param col The column coordinate of the central point from which to mark adjacent cells.\n             */\n            private void markAdjacentAsImpossible(int row, int col) {\n                // Define the four cardinal directions\n                int[][] directions = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\n        \n                // Iterate through each direction to mark adjacent cells as impossible\n                for (int[] dir : directions) {\n                    int newRow = row + dir[0];\n                    int newCol = col + dir[1];\n        \n                    // Check if the adjacent cell is within the game board boundaries\n                    if (isValidCoordinate(newRow, newCol)) {\n                        // Mark the cell as impossible for ship placement\n                        impossibleCells[newRow][newCol] = true;\n                    }\n                }\n            }\n        \n        \n        \n            /**\n             * Calculates the probability of a cell being occupied by a part of a ship.\n             * This method considers both horizontal and vertical placement possibilities for all\n             * unsunk ship sizes. It sums up the probabilities for each ship size that can be placed\n             * at the given cell, considering the cell's current state and the game's constraints.\n             * Cells marked as impossible for ship placement immediately return a probability of zero.\n             *\n             * @param row The row coordinate of the cell for which to calculate the probability.\n             * @param col The column coordinate of the cell for which to calculate the probability.\n             * @return The calculated probability of the cell being occupied by a ship.\n             */\n            private double calculateCellProbability(int row, int col) {\n                // If the cell is marked as impossible, its probability is zero\n                if (impossibleCells[row][col]) {\n                    return 0.0;\n                }\n        \n                double probability = 0.0;  // Initialize probability\n        \n                // Iterate through the sizes of unsunk ships\n                for (int shipSize : battleShip.getShipSizes()) {\n                    // Skip calculation for ship sizes that are already sunk\n                    if (sunkShipSizes.contains(shipSize)) {\n                        continue;\n                    }\n        \n                    // Add probability for horizontal placement if possible\n                    if (canPlaceShipHorizontally(row, col, shipSize)) {\n                        probability += (1.0 / shipSize);\n                    }\n        \n                    // Add probability for vertical placement if possible\n                    if (canPlaceShipVertically(row, col, shipSize)) {\n                        probability += (1.0 / shipSize);\n                    }\n                }\n        \n                return probability;  // Return the summed probability\n            }\n        \n        \n            /**\n             * Determines whether the current state of the game can be considered as the early game phase.\n             * This method assesses the stage of the game based on the number of hits and total shots made.\n             * It uses a percentage threshold of the game board to define the early game, along with a dynamic\n             * threshold based on the sizes of the ships. This assessment helps in deciding which strategy to\n             * apply during the game - different strategies might be more effective in early or later stages.\n             *\n             * @return true if the game is still in its early stages, false otherwise.\n             */\n            private boolean isEarlyGame() {\n                int totalHits = hitList.size();  // Count of total hits made so far\n                int totalShots = getTotalShots();  // Total number of shots fired so far\n        \n                // Define threshold for considering it as early game based on board size (e.g., 25% of the board)\n                int earlyGamePercentageThreshold = (int) (gameSize * gameSize * 0.25);\n        \n                // Dynamic threshold for hits, based on ship sizes\n                int hitThreshold = determineHitThreshold();\n        \n                // Determine if it's still early game based on the number of shots and hits\n                return totalHits < hitThreshold && totalShots < earlyGamePercentageThreshold;\n            }\n        \n        \n            /**\n             * Determines the hit threshold to help define the early game phase.\n             * This method calculates a dynamic threshold based on the sizes of the ships in the game,\n             * specifically using the size of the smallest ship. The logic assumes that the game moves\n             * out of the early phase after hitting at least half of the smallest ship. This threshold\n             * is used in conjunction with other criteria to determine the game's current stage and\n             * adjust the bots' strategy accordingly.\n             *\n             * @return The dynamically calculated hit threshold based on the smallest ship's size.\n             */\n            private int determineHitThreshold() {\n                // Find the size of the smallest ship in the game\n                int smallestShipSize = findSmallestShipSize();\n        \n                // Calculate the hit threshold as half the size of the smallest ship\n                return smallestShipSize / 2;\n            }\n        \n        \n            /**\n             * Identifies the size of the smallest ship in the game.\n             * This method iterates through the array of initial ship sizes and finds the smallest value.\n             * The smallest ship size is an important factor in various strategic calculations, such as\n             * determining hit thresholds and assessing the game's stage.\n             *\n             * @return The size of the smallest ship in the initial ship sizes array.\n             */\n            private int findSmallestShipSize() {\n                int smallestSize = Integer.MAX_VALUE;  // Initialize with the maximum possible value\n        \n                // Iterate through each ship size\n                for (int size : initialShipSizes) {\n                    // Update the smallestSize if a smaller ship size is found\n                    if (size < smallestSize) {\n                        smallestSize = size;\n                    }\n                }\n        \n                return smallestSize;  // Return the smallest ship size\n            }\n        \n        \n        \n            /**\n             * Calculates the total number of shots fired in the game.\n             * This method iterates over the entire game board and counts the number of cells that\n             * are not in the 'Empty' state, indicating that a shot has been fired at those cells.\n             * It provides an accurate count of all shots made, used in determining the game's stage\n             * and in various strategic decision-making processes.\n             *\n             * @return The total number of shots fired so far in the game.\n             */\n            private int getTotalShots() {\n                int totalShots = 0;  // Initialize the counter for total shots\n        \n                // Iterate through each cell on the game board\n                for (int i = 0; i < gameSize; i++) {\n                    for (int j = 0; j < gameSize; j++) {\n                        // Increment the counter for each cell that is not empty (i.e., a shot has been fired)\n                        if (board[i][j] != CellState.Empty) {\n                            totalShots++;\n                        }\n                    }\n                }\n        \n                return totalShots;  // Return the total number of shots\n            }\n        \n        \n            /**\n             * Calculates the probability of a ship of a specific size being located at a given cell.\n             * This method considers both horizontal and vertical placements of the ship at the specified coordinates.\n             * It calculates the probability based on whether the ship can be placed in those orientations, given the\n             * current state of the game board. The method also adjusts the probability based on adjacent hits and the\n             * potential orientation of ships. If the ship size has already been sunk, it skips the calculation and returns zero.\n             *\n             * @param x The x-coordinate (row) of the cell for probability calculation.\n             * @param y The y-coordinate (column) of the cell for probability calculation.\n             * @param shipSize The size of the ship for which to calculate the probability.\n             * @return The calculated probability of a ship of the given size being at the specified cell.\n             */\n            private double calculateProbabilityForShipSize(int x, int y, int shipSize) {\n                // Skip calculation and return zero if the ship size has already been sunk\n                if (sunkShipSizes.contains(shipSize)) {\n                    return 0.0;\n                }\n        \n                double probability = 0.0;  // Initialize probability\n        \n                // Add to the probability if the ship can be placed horizontally at the cell\n                if (canPlaceShipHorizontally(x, y, shipSize)) {\n                    probability += calculateHorizontalProbability(x, y, shipSize);\n                }\n        \n                // Add to the probability if the ship can be placed vertically at the cell\n                if (canPlaceShipVertically(x, y, shipSize)) {\n                    probability += calculateVerticalProbability(x, y, shipSize);\n                }\n        \n                // Adjust the probability based on adjacent hits and potential ship orientation\n                probability *= adjustProbabilityBasedOnHits(x, y);\n        \n                // Apply additional factors based on patterns or other strategic considerations\n                double patternProbabilityFactor = getPatternProbabilityFactor(x, y, shipSize);\n                probability *= patternProbabilityFactor;\n        \n                return probability;  // Return the final calculated probability\n            }\n        \n        \n            /**\n             * Adjusts the probability of a cell being occupied by a ship based on adjacent hits.\n             * This method increases the probability factor if the cell is adjacent to a hit, considering\n             * potential ship patterns. It checks for hits in all four cardinal directions and identifies\n             * whether the hits form a horizontal or vertical pattern. The probability is adjusted higher\n             * if adjacent hits suggest a possible extension of a ship in those directions. This adjustment\n             * helps in refining the shot selection by taking into account the orientation of partially hit ships.\n             *\n             * @param x The x-coordinate (row) of the cell for which to adjust the probability.\n             * @param y The y-coordinate (column) of the cell for which to adjust the probability.\n             * @return The adjusted probability factor for the cell based on adjacent hits.\n             */\n            private double adjustProbabilityBasedOnHits(int x, int y) {\n                double adjustmentFactor = 1.0;  // Initialize adjustment factor\n        \n                // Flags to track if there are adjacent hits forming horizontal or vertical patterns\n                boolean horizontalHit = false, verticalHit = false;\n        \n                // Check for hits in all four cardinal directions\n                int[][] directions = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};\n                for (int[] dir : directions) {\n                    int adjacentX = x + dir[0];\n                    int adjacentY = y + dir[1];\n        \n                    // Increase probability if the adjacent cell is a hit\n                    if (isValidCoordinate(adjacentX, adjacentY) && board[adjacentX][adjacentY] == CellState.Hit) {\n                        adjustmentFactor *= 1.5;  // Increase factor for cells adjacent to a hit\n        \n                        // Determine if hits form horizontal or vertical patterns\n                        if (dir[0] == 0) horizontalHit = true;  // Horizontal pattern\n                        if (dir[1] == 0) verticalHit = true;   // Vertical pattern\n                    }\n                }\n        \n                // Further adjust probability based on detected hit patterns\n                if (horizontalHit && verticalHit) {\n                    // Hits in multiple directions may suggest proximity to multiple ships\n                    adjustmentFactor *= 1.2;\n                } else if (horizontalHit) {\n                    // Increase probability for horizontal extension if horizontal hits detected\n                    adjustmentFactor *= predictHorizontalExtension(x, y);\n                } else if (verticalHit) {\n                    // Increase probability for vertical extension if vertical hits detected\n                    adjustmentFactor *= predictVerticalExtension(x, y);\n                }\n        \n                return adjustmentFactor;  // Return the adjusted probability factor\n            }\n        \n        \n            /**\n             * Predicts the likelihood of a horizontal extension of a ship from a given cell.\n             * This method adjusts a probability factor based on the state of cells to the left and right\n             * of the given coordinates. It increases the factor if there are hits adjacent to the cell\n             * (suggesting a possible horizontal ship extension), and decreases it if there are misses\n             * (suggesting the absence of a ship in that direction). This probability adjustment aids in\n             * refining the bots targeting strategy, especially when determining the orientation of partially hit ships.\n             *\n             * @param x The x-coordinate (row) of the cell for which to predict the horizontal extension.\n             * @param y The y-coordinate (column) of the cell for which to predict the horizontal extension.\n             * @return The adjusted factor indicating the likelihood of a horizontal ship extension from the cell.\n             */\n            private double predictHorizontalExtension(int x, int y) {\n                double extensionFactor = 1.0;  // Initialize the extension factor\n        \n                // Check for hits or misses to the left of the cell\n                if (y > 0) {\n                    if (board[x][y - 1] == CellState.Hit) extensionFactor *= 1.2; // Increase if there is a hit on the left\n                    if (board[x][y - 1] == CellState.Miss) extensionFactor *= 0.8; // Decrease if there is a miss on the left\n                }\n        \n                // Check for hits or misses to the right of the cell\n                if (y < gameSize - 1) {\n                    if (board[x][y + 1] == CellState.Hit) extensionFactor *= 1.2; // Increase if there is a hit on the right\n                    if (board[x][y + 1] == CellState.Miss) extensionFactor *= 0.8; // Decrease if there is a miss on the right\n                }\n        \n                return extensionFactor;  // Return the probability extension factor\n            }\n        \n        \n        \n            /**\n             * Predicts the likelihood of a vertical extension of a ship from a given cell.\n             * This method adjusts a probability factor based on the state of cells above and below\n             * the given coordinates. It increases the factor if there are hits adjacent to the cell\n             * (suggesting a possible vertical ship extension), and decreases it if there are misses\n             * (suggesting the absence of a ship in that direction). This probability adjustment is\n             * instrumental in refining the bots targeting strategy, particularly when determining\n             * the orientation of partially hit ships.\n             *\n             * @param x The x-coordinate (row) of the cell for which to predict the vertical extension.\n             * @param y The y-coordinate (column) of the cell for which to predict the vertical extension.\n             * @return The adjusted factor indicating the likelihood of a vertical ship extension from the cell.\n             */\n            private double predictVerticalExtension(int x, int y) {\n                double extensionFactor = 1.0;  // Initialize the extension factor\n        \n                // Check for hits or misses above the cell\n                if (x > 0) {\n                    if (board[x - 1][y] == CellState.Hit) extensionFactor *= 1.2; // Increase if there is a hit above\n                    if (board[x - 1][y] == CellState.Miss) extensionFactor *= 0.8; // Decrease if there is a miss above\n                }\n        \n                // Check for hits or misses below the cell\n                if (x < gameSize - 1) {\n                    if (board[x + 1][y] == CellState.Hit) extensionFactor *= 1.2; // Increase if there is a hit below\n                    if (board[x + 1][y] == CellState.Miss) extensionFactor *= 0.8; // Decrease if there is a miss below\n                }\n        \n                return extensionFactor;  // Return the probability extension factor\n            }\n        \n        \n        \n            /**\n             * Calculates an overall pattern probability factor for a cell based on various strategic elements.\n             * This method combines several factors that influence the probability of a ship being at a given cell.\n             * It includes an edge avoidance factor to account for the less likely placement of ships at the edges,\n             * a central concentration factor that increases probabilities towards the center of the board, and\n             * a randomness factor to add variability and unpredictability to the bots' strategy. These combined\n             * factors help in making a more nuanced and effective probability assessment for each cell.\n             *\n             * @param x The x-coordinate (row) of the cell for which to calculate the pattern probability factor.\n             * @param y The y-coordinate (column) of the cell for which to calculate the pattern probability factor.\n             * @param shipSize The size of the ship being considered for the probability calculation.\n             * @return The overall pattern probability factor for the cell.\n             */\n            private double getPatternProbabilityFactor(int x, int y, int shipSize) {\n                // Calculate individual factors influencing the cell's probability\n                double edgeAvoidanceFactor = calculateEdgeAvoidanceFactor(x, y, shipSize);\n                double centralConcentrationFactor = calculateCentralConcentrationFactor(x, y);\n                double randomnessFactor = calculateRandomnessFactor();\n        \n                // Combine the factors to compute the overall pattern probability factor\n                return edgeAvoidanceFactor * centralConcentrationFactor * randomnessFactor;\n            }\n        \n        \n            /**\n             * Calculates the edge avoidance factor for a cell based on its proximity to the nearest edge and the ship size.\n             * This method assesses how close a given cell is to the nearest edge of the game board. The factor is adjusted\n             * based on the size of the ship being considered, with the assumption that larger ships are less likely to be\n             * placed close to the edges. The edge avoidance factor is used as part of the strategy to estimate the probability\n             * of a ship being located at a particular cell, especially for cells near the board's boundaries.\n             *\n             * @param x The x-coordinate (row) of the cell for which to calculate the edge avoidance factor.\n             * @param y The y-coordinate (column) of the cell for which to calculate the edge avoidance factor.\n             * @param shipSize The size of the ship being considered for the calculation.\n             * @return The calculated edge avoidance factor for the cell.\n             */\n            private double calculateEdgeAvoidanceFactor(int x, int y, int shipSize) {\n                // Calculate the cell's distance from the nearest edge\n                int edgeDistance = Math.min(Math.min(x, gameSize - x - 1), Math.min(y, gameSize - y - 1));\n        \n                // Determine the influence of ship size on edge placement\n                double sizeFactor = 1.0 - ((double) shipSize / gameSize);\n        \n                // Combine edge distance and ship size factors to compute the edge avoidance factor\n                return 1.0 - sizeFactor * (1.0 / (edgeDistance + 1));\n            }\n        \n        \n        \n            /**\n             * Calculates the central concentration factor for a cell, increasing its probability based on proximity to the center of the board.\n             * This method computes the cell's distance from the center of the game board and adjusts the probability factor accordingly,\n             * under the assumption that ships are more likely to be placed closer to the center. The central concentration factor is\n             * a part of the overall strategy to refine the probability map, giving more weight to cells near the center of the board.\n             *\n             * @param x The x-coordinate (row) of the cell for which to calculate the central concentration factor.\n             * @param y The y-coordinate (column) of the cell for which to calculate the central concentration factor.\n             * @return The calculated central concentration factor for the cell.\n             */\n            private double calculateCentralConcentrationFactor(int x, int y) {\n                // Determine the center coordinates of the game board\n                int centerX = gameSize / 2;\n                int centerY = gameSize / 2;\n        \n                // Calculate the Manhattan distance from the cell to the center of the board\n                int distanceFromCenter = Math.abs(x - centerX) + Math.abs(y - centerY);\n        \n                // Calculate and return the central concentration factor, increasing as the cell gets closer to the center\n                return 1.0 + 0.5 * (1.0 / (distanceFromCenter + 1));\n            }\n        \n        \n            /**\n             * Generates a randomness factor to introduce variability into the bots decision-making process.\n             * This method calculates a random factor within a defined range to add an element of unpredictability\n             * to the bots' strategy. This randomness helps in avoiding overly predictable patterns in the bots\n             * shot selection and probability assessments, making it more challenging for opponents to anticipate\n             * the bots actions. The randomness factor is integrated into various probability calculations.\n             *\n             * @return A random factor within a specified range (e.g., between 0.8 and 1.2).\n             */\n            private double calculateRandomnessFactor() {\n                // Generate and return a random factor within the range of 0.8 to 1.2\n                return 0.8 + 0.4 * Math.random(); // Random factor between 0.8 and 1.2\n            }\n        \n        \n        \n            /**\n             * Selects the next targeted shot based on updated probability assessments.\n             * This method first rebuilds the probability queue to reflect the latest probabilities\n             * for each cell on the game board. It then selects the cell with the highest probability\n             * of containing a ship, ensuring that the cell is empty (i.e., not already shot at). If no\n             * high probability shots are available, it defaults to a random shot as a fallback strategy.\n             *\n             * @return The point representing the coordinates of the next targeted shot,\n             *         chosen based on the highest probability or randomly if no suitable target is found.\n             */\n            private Point getTargetedShot() {\n                // Rebuild the probability queue to include the latest probabilities\n                rebuildProbabilityQueue();\n        \n                // Stream through the probability queue, filter for empty cells, and select the first highest probability\n                return probabilityQueue.stream()\n                        .filter(cellProb -> board[cellProb.point.x][cellProb.point.y] == CellState.Empty)\n                        .findFirst()\n                        .map(cellProb -> cellProb.point)\n                        .orElseGet(this::randomShot); // Fallback to a random shot if no high probability cells are found\n            }\n        \n        \n        \n            /**\n             * Represents the probability of a cell being occupied by a part of a ship.\n             * This class is used to pair a point on the game board with its corresponding probability score.\n             * It implements the Comparable interface to allow sorting of these objects based on their probability,\n             * facilitating the selection of the most probable shots. The comparison is done in descending order\n             * of probability, meaning higher probabilities come first.\n             */\n            private static class CellProbability implements Comparable<CellProbability> {\n                Point point;          // The point on the game board\n                double probability;   // The probability associated with this point\n        \n                /**\n                 * Constructs a CellProbability object with a specific point and its probability.\n                 *\n                 * @param point The point on the game board.\n                 * @param probability The probability of a ship being at this point.\n                 */\n                public CellProbability(Point point, double probability) {\n                    this.point = point;\n                    this.probability = probability;\n                }\n        \n                /**\n                 * Compares this CellProbability object with another to determine their ordering.\n                 *\n                 * @param other Another CellProbability object to be compared against.\n                 * @return A negative integer, zero, or a positive integer as this object is less than,\n                 *         equal to, or greater than the specified object in terms of probability.\n                 */\n                @Override\n                public int compareTo(CellProbability other) {\n                    // Sort in descending order of probability\n                    return Double.compare(other.probability, this.probability);\n                }\n            }\n        \n        }`\n}, {\n  name: \"BattleShipAPI.java\",\n  code: `package BattleShipAPI;\n\n        import java.awt.Point;\n        import java.util.ArrayList;\n        import java.util.Iterator;\n        import java.util.Random;\n        \n        public class BattleShipAPI {\n            private static final boolean DEBUGMODE = false;\n            public static final int BOARD_SIZE = 10;\n            public static final int[] SHIP_SIZES = new int[]{5, 4, 3, 2, 2, 1, 1};\n            private int numberOfGames;\n            private int boardSize;\n            private boolean success;\n            private int[] shipSizes;\n            private CellState[][] board;\n            private ArrayList<Ship> ships;\n            private ArrayList<Point> hits;\n            private ArrayList<Point> misses;\n            private Random random = new Random(-1412567296L);\n            private int totalShots;\n            private long timeRequired;\n            private BattleShipBot bot;\n        \n            public static String getVersion() {\n                return \"B A T T L E S H I P - Version 3.0 [January 23,2024]\";\n            }\n        \n            public BattleShipAPI(int numberOfGames, BattleShipBot bot) {\n                this.bot = bot;\n                this.numberOfGames = numberOfGames;\n                this.success = false;\n                this.boardSize = 10;\n                this.reset();\n                bot.initialize(this);\n            }\n        \n            public int[] run() {\n                long start = System.nanoTime();\n                this.totalShots = 0;\n                int[] gameScores = new int[this.numberOfGames];\n                this.success = false;\n        \n                try {\n                    for(int game = 0; game < this.numberOfGames; ++game) {\n                        this.reset();\n                        this.bot.initialize(this);\n        \n                        while(!this.allSunk()) {\n                            this.bot.fireShot();\n                        }\n        \n                        int gameShots = this.totalShotsTaken();\n                        gameScores[game] = gameShots;\n                        this.totalShots += gameShots;\n                        this.success = true;\n                    }\n                } catch (Exception var6) {\n                    System.out.println(\"RUNNING of Solution Failed \" + this.bot.getClass());\n                    System.out.println(var6.getMessage());\n                    var6.printStackTrace();\n                }\n        \n                this.timeRequired = (System.nanoTime() - start) / 1000000L;\n                return gameScores;\n            }\n        \n            public void reportResults() {\n                System.out.println(\"------------------------------------------------------------\");\n                System.out.printf(\"BattleShip 2 - Results for %s\\n\", this.bot.getClass().getName());\n                System.out.println(\"Author : \" + this.bot.getAuthors());\n                System.out.println(\"------------------------------------------------------------\");\n                if (this.success) {\n                    System.out.printf(\"The Average Score over %d games    = %.2f\\n\", this.numberOfGames, (double)this.totalShots / (double)this.numberOfGames);\n                    System.out.printf(\"Time required to complete %d games = %d ms\\n\", this.numberOfGames, this.timeRequired);\n                } else {\n                    System.out.println(\"Solution did not complete - Exception thrown in code\");\n                }\n        \n                System.out.println(\"------------------------------------------------------------\");\n            }\n        \n            private void reset() {\n                this.hits = new ArrayList();\n                this.misses = new ArrayList();\n                this.shipSizes = SHIP_SIZES;\n                this.board = new CellState[this.boardSize][this.boardSize];\n        \n                int i;\n                for(i = 0; i < this.boardSize; ++i) {\n                    for(int y = 0; y < this.boardSize; ++y) {\n                        this.board[i][y] = CellState.Empty;\n                    }\n                }\n        \n                this.ships = new ArrayList();\n        \n                for(i = 0; i < this.shipSizes.length; ++i) {\n                    Ship testShip = null;\n        \n                    do {\n                        Point location = new Point(this.random.nextInt(this.boardSize), this.random.nextInt(this.boardSize));\n                        ShipOrientation orientation = ShipOrientation.values()[this.random.nextInt(ShipOrientation.values().length)];\n                        testShip = new Ship(this.shipSizes[i], location, orientation);\n                        boolean placed = Ship.place(this.boardSize, testShip, this.ships);\n                        if (placed) {\n                        }\n                    } while(!testShip.getIsPlaced());\n        \n                    this.ships.add(testShip);\n                }\n        \n            }\n        \n            public boolean allSunk() {\n                int numberOfHitCells = 0;\n        \n                for(int y = 0; y < this.boardSize; ++y) {\n                    for(int x = 0; x < this.boardSize; ++x) {\n                        if (this.board[x][y] == CellState.Hit) {\n                            ++numberOfHitCells;\n                        }\n                    }\n                }\n        \n                return numberOfHitCells == this.totalShipLengths();\n            }\n        \n            public int totalShotsTaken() {\n                return this.hits.size() + this.misses.size();\n            }\n        \n            public int[] getShipSizes() {\n                return this.shipSizes;\n            }\n        \n            public boolean shoot(Point shot) {\n                boolean hit = this.shipAt(shot);\n                if (hit) {\n                    this.board[shot.x][shot.y] = CellState.Hit;\n                    this.hits.add(shot);\n                } else {\n                    this.board[shot.x][shot.y] = CellState.Miss;\n                    this.misses.add(shot);\n                }\n        \n                return this.shipAt(shot);\n            }\n        \n            public int numberOfShipsSunk() {\n                int num = 0;\n                Iterator var2 = this.ships.iterator();\n        \n                while(var2.hasNext()) {\n                    Ship s = (Ship)var2.next();\n                    int length = s.getLength();\n                    Point pos = s.getLocation();\n                    boolean sunk = true;\n                    int y;\n                    if (s.getOrientation() == ShipOrientation.Horizontal) {\n                        for(y = 0; y < length; ++y) {\n                            sunk &= this.board[pos.x + y][pos.y] == CellState.Hit;\n                        }\n                    } else {\n                        for(y = 0; y < length; ++y) {\n                            sunk &= this.board[pos.x][pos.y + y] == CellState.Hit;\n                        }\n                    }\n        \n                    if (sunk) {\n                        ++num;\n                    }\n                }\n        \n                return num;\n            }\n        \n            private boolean shipAt(Point p) {\n                Iterator var2 = this.ships.iterator();\n        \n                Ship s;\n                do {\n                    if (!var2.hasNext()) {\n                        return false;\n                    }\n        \n                    s = (Ship)var2.next();\n                } while(!s.isAt(p));\n        \n                return true;\n            }\n        \n            private void printBoard() {\n                System.out.print(\"\\n.  \");\n        \n                int y;\n                for(y = 0; y < this.boardSize; ++y) {\n                    System.out.printf(\"%2d \", y);\n                }\n        \n                for(y = 0; y < this.boardSize; ++y) {\n                    System.out.printf(\"\\n%2d \", y);\n        \n                    for(int x = 0; x < this.boardSize; ++x) {\n                        System.out.printf(\" %s \", this.board[x][y]);\n                    }\n                }\n        \n                System.out.println();\n            }\n        \n            private void debugPrintBoard() {\n                CellState[][] dboard = new CellState[this.boardSize][this.boardSize];\n        \n                int y;\n                int x;\n                for(y = 0; y < this.boardSize; ++y) {\n                    for(x = 0; x < this.boardSize; ++x) {\n                        if (this.shipAt(new Point(y, x))) {\n                            dboard[y][x] = CellState.Hit;\n                        } else {\n                            dboard[y][x] = CellState.Empty;\n                        }\n                    }\n                }\n        \n                System.out.print(\"\\n.  \");\n        \n                for(y = 0; y < this.boardSize; ++y) {\n                    System.out.printf(\"%2d \", y);\n                }\n        \n                for(y = 0; y < this.boardSize; ++y) {\n                    System.out.printf(\"\\n%2d \", y);\n        \n                    for(x = 0; x < this.boardSize; ++x) {\n                        System.out.printf(\" %s \", dboard[x][y]);\n                    }\n                }\n        \n                System.out.println();\n            }\n        \n            private int totalShipLengths() {\n                int length = 0;\n        \n                Ship s;\n                for(Iterator var2 = this.ships.iterator(); var2.hasNext(); length += s.getLength()) {\n                    s = (Ship)var2.next();\n                }\n        \n                return length;\n            }\n        \n            public static void main(String[] args) {\n                System.out.println(getVersion());\n            }\n        }`\n}, {\n  name: \"BattleShipBot.java\",\n  code: `package BattleShipAPI;\n\n        public interface BattleShipBot {\n            void initialize(BattleShipAPI var1);\n        \n            void fireShot();\n        \n            String getAuthors();\n        }`\n}, {\n  name: \"CellState.java\",\n  code: `package BattleShipAPI;\n\n        public enum CellState {\n            Empty,\n            Hit,\n            Miss;\n        \n            private CellState() {\n            }\n        \n            public String toString() {\n                switch (this) {\n                    case Empty:\n                        return \".\";\n                    case Hit:\n                        return \"X\";\n                    case Miss:\n                        return \"o\";\n                    default:\n                        return \"?\";\n                }\n            }\n        }`\n}, {\n  name: \"Ship.java\",\n  code: `package BattleShipAPI;\n\n        import java.awt.Point;\n        import java.util.ArrayList;\n        import java.util.Iterator;\n        \n        public final class Ship {\n            private boolean isPlaced = false;\n            private Point location;\n            private ShipOrientation orientation;\n            private int length;\n        \n            public Ship(int length, Point location, ShipOrientation orientation) {\n                if (length <= 0) {\n                    throw new IllegalArgumentException(\"Invalid length specified: must be >= 1 \");\n                } else {\n                    this.length = length;\n                    this.location = location;\n                    this.orientation = orientation;\n                }\n            }\n        \n            public boolean getIsPlaced() {\n                return this.isPlaced;\n            }\n        \n            public Point getLocation() {\n                return this.location;\n            }\n        \n            public ShipOrientation getOrientation() {\n                return this.orientation;\n            }\n        \n            public int getLength() {\n                return this.length;\n            }\n        \n            public static boolean place(int boardSize, Ship newShip, ArrayList<Ship> ships) {\n                newShip.isPlaced = false;\n                if (!newShip.isValid(boardSize)) {\n                    return false;\n                } else {\n                    if (ships != null) {\n                        Iterator var3 = ships.iterator();\n        \n                        label97:\n                        while(true) {\n                            while(true) {\n                                if (!var3.hasNext()) {\n                                    break label97;\n                                }\n        \n                                Ship ship = (Ship)var3.next();\n                                int x;\n                                int y;\n                                if (ship.orientation == ShipOrientation.Horizontal) {\n                                    x = ship.getLocation().y;\n        \n                                    for(y = ship.getLocation().x; y < ship.getLocation().x + ship.getLength(); ++y) {\n                                        if (y == ship.getLocation().x && y > 0 && newShip.isAt(new Point(y - 1, x))) {\n                                            return false;\n                                        }\n        \n                                        if (y == ship.getLocation().x + ship.getLength() - 1 && y < boardSize - 1 && newShip.isAt(new Point(y + 1, x))) {\n                                            return false;\n                                        }\n        \n                                        if (newShip.isAt(new Point(y, x)) || newShip.isAt(new Point(y, Math.max(0, x - 1))) || newShip.isAt(new Point(y, Math.min(boardSize - 1, x + 1)))) {\n                                            return false;\n                                        }\n                                    }\n                                } else if (ship.orientation == ShipOrientation.Vertical) {\n                                    x = ship.getLocation().x;\n        \n                                    for(y = ship.getLocation().y; y < ship.getLocation().y + ship.getLength(); ++y) {\n                                        if (y == ship.getLocation().y && y > 0 && newShip.isAt(new Point(x, y - 1))) {\n                                            return false;\n                                        }\n        \n                                        if (y == ship.getLocation().y + ship.getLength() - 1 && y < boardSize - 1 && newShip.isAt(new Point(x, y + 1))) {\n                                            return false;\n                                        }\n        \n                                        if (newShip.isAt(new Point(x, y)) || newShip.isAt(new Point(Math.max(0, x - 1), y)) || newShip.isAt(new Point(Math.min(boardSize - 1, x + 1), y))) {\n                                            return false;\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n        \n                    newShip.isPlaced = true;\n                    return true;\n                }\n            }\n        \n            public boolean isAt(Point p) {\n                if (this.getOrientation() == ShipOrientation.Horizontal) {\n                    return p.y == this.location.y && p.x >= this.location.x && p.x < this.location.x + this.length;\n                } else {\n                    return p.x == this.location.x && p.y >= this.location.y && p.y < this.location.y + this.length;\n                }\n            }\n        \n            public boolean isValid(int boardSize) {\n                if (this.location.x >= 0 && this.location.y >= 0) {\n                    if (this.orientation == ShipOrientation.Horizontal) {\n                        if (this.location.y >= boardSize || this.location.x + this.length > boardSize) {\n                            return false;\n                        }\n                    } else if (this.location.x >= boardSize || this.location.y + this.length > boardSize) {\n                        return false;\n                    }\n        \n                    return true;\n                } else {\n                    return false;\n                }\n            }\n        }`\n}, {\n  name: 'ShipOrientation.java',\n  code: `package BattleShipAPI;\n\n    public enum ShipOrientation {\n        Vertical,\n        Horizontal;\n    \n        private ShipOrientation() {\n        }\n    }`\n}];\nconst BattleShipBot = () => {\n  _s();\n  const navigate = useNavigate();\n  const handleBack = () => {\n    navigate(-1); // Navigate back to the previous page\n  };\n  return /*#__PURE__*/_jsxDEV(Box, {\n    sx: style.container,\n    children: [/*#__PURE__*/_jsxDEV(Starfield, {}, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 1731,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(IconButton, {\n      onClick: handleBack,\n      sx: style.backButton,\n      children: /*#__PURE__*/_jsxDEV(ArrowBackIcon, {}, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1733,\n        columnNumber: 17\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 1732,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(Grid, {\n      container: true,\n      spacing: 2,\n      children: [/*#__PURE__*/_jsxDEV(ProjectOverview, {}, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1737,\n        columnNumber: 17\n      }, this), /*#__PURE__*/_jsxDEV(YourApproach, {}, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1738,\n        columnNumber: 17\n      }, this), /*#__PURE__*/_jsxDEV(TechnicalImplementation, {}, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1739,\n        columnNumber: 17\n      }, this), /*#__PURE__*/_jsxDEV(Results, {}, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1740,\n        columnNumber: 17\n      }, this), /*#__PURE__*/_jsxDEV(LearningsReflections, {}, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1741,\n        columnNumber: 17\n      }, this), /*#__PURE__*/_jsxDEV(CodeAccessibility, {}, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1742,\n        columnNumber: 17\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 1736,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(LandscapeOverlay, {}, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 1745,\n      columnNumber: 13\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 1730,\n    columnNumber: 9\n  }, this);\n};\n_s(BattleShipBot, \"CzcTeTziyjMsSrAVmHuCCb6+Bfg=\", false, function () {\n  return [useNavigate];\n});\n_c = BattleShipBot;\nconst ProjectOverview = () => {\n  return /*#__PURE__*/_jsxDEV(Grid, {\n    item: true,\n    xs: 12,\n    children: [/*#__PURE__*/_jsxDEV(Typography, {\n      variant: \"h2\",\n      sx: style.header,\n      children: [/*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1753,\n        columnNumber: 56\n      }, this), /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1753,\n        columnNumber: 65\n      }, this), \"Battleship Strategy Bot\"]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 1753,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(Typography, {\n      variant: \"body1\",\n      sx: style.paragraph,\n      children: \"The BattleShipBot, is an advanced Battleship game bot designed to play against an opponent with strategic precision. This bot utilizes a unique combination of probabilistic and targeted strategies to enhance its gameplay, aiming to achieve the lowest average number of shots across multiple games on a 10x10 grid.\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 1756,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(Typography, {\n      variant: \"body1\",\n      sx: style.paragraph,\n      children: \"Objective: Minimize the number of shots required to sink all enemy ships across 10,000 games.\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 1761,\n      columnNumber: 13\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 1752,\n    columnNumber: 9\n  }, this);\n};\n_c2 = ProjectOverview;\nconst YourApproach = () => {\n  return /*#__PURE__*/_jsxDEV(Grid, {\n    item: true,\n    xs: 12,\n    children: [/*#__PURE__*/_jsxDEV(Typography, {\n      variant: \"h4\",\n      sx: style.featureHeading,\n      children: \"My Approach\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 1771,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(Typography, {\n      variant: \"body1\",\n      sx: style.paragraph,\n      children: \"BattleShipBot implements a hybrid strategy, integrating both probabilistic and targeted approaches. It leverages historical data to make educated guesses in the early game and switches to a more focused approach once a ship is hit, targeting specific areas to effectively sink ships.\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 1772,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(Typography, {\n      variant: \"body1\",\n      sx: style.paragraph,\n      children: \"The bot employs arrays, sets, maps, and priority queues to manage the game state, track ship placements, and calculate shot probabilities. This selection of data structures ensures efficient data management and optimal decision-making during gameplay.\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 1777,\n      columnNumber: 13\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 1770,\n    columnNumber: 9\n  }, this);\n};\n_c3 = YourApproach;\nconst TechnicalImplementation = () => {\n  return /*#__PURE__*/_jsxDEV(Grid, {\n    item: true,\n    xs: 12,\n    children: [/*#__PURE__*/_jsxDEV(Typography, {\n      variant: \"h4\",\n      sx: style.featureHeading,\n      children: \"Technical Implementation\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 1789,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(Typography, {\n      variant: \"body1\",\n      sx: style.paragraph,\n      children: [\"One challenge was efficiently managing the probabilistic calculations for shot selection. This was solved by using a priority queue to rank cells based on their likelihood of containing a ship, significantly optimizing the shot selection process.\", /*#__PURE__*/_jsxDEV(\"div\", {\n        children: filesData.map(fileData => /*#__PURE__*/_jsxDEV(FileTreeItem, {\n          fileName: fileData.name,\n          codeSnippet: fileData.code\n        }, fileData.name, false, {\n          fileName: _jsxFileName,\n          lineNumber: 1796,\n          columnNumber: 25\n        }, this))\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1794,\n        columnNumber: 17\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 1790,\n      columnNumber: 13\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 1788,\n    columnNumber: 9\n  }, this);\n};\n_c4 = TechnicalImplementation;\nconst Results = () => {\n  return /*#__PURE__*/_jsxDEV(Grid, {\n    item: true,\n    xs: 12,\n    children: [/*#__PURE__*/_jsxDEV(Typography, {\n      variant: \"h4\",\n      sx: style.featureHeading,\n      children: \"Results\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 1807,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(Typography, {\n      variant: \"body1\",\n      sx: style.paragraph,\n      children: \"The BattleShip bot achieved an impressive average shot count well below the goal target, showcasing its effectiveness in strategically playing Battleship. The precise combination of algorithms and data structures played a pivotal role in this achievement.\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 1808,\n      columnNumber: 13\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 1806,\n    columnNumber: 9\n  }, this);\n};\n_c5 = Results;\nconst LearningsReflections = () => {\n  return /*#__PURE__*/_jsxDEV(Grid, {\n    item: true,\n    xs: 12,\n    children: [/*#__PURE__*/_jsxDEV(Typography, {\n      variant: \"h4\",\n      sx: style.featureHeading,\n      children: \"Learnings and Reflections\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 1820,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(Typography, {\n      variant: \"body1\",\n      sx: style.paragraph,\n      children: \"This project enhanced my understanding of algorithm efficiency and data structure selection. The importance of choosing the right strategy based on game context was a key takeaway, offering insights into adaptive algorithm design.\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 1821,\n      columnNumber: 13\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 1819,\n    columnNumber: 9\n  }, this);\n};\n_c6 = LearningsReflections;\nconst CodeAccessibility = () => {\n  return /*#__PURE__*/_jsxDEV(Grid, {\n    item: true,\n    xs: 12,\n    children: [/*#__PURE__*/_jsxDEV(Typography, {\n      variant: \"h4\",\n      sx: style.featureHeading,\n      children: \"Code Accessibility\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 1833,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(Typography, {\n      variant: \"body1\",\n      sx: style.paragraph,\n      children: \"Access the complete code for this project via the downloadable ZIP file. This comprehensive package contains all the necessary files and documentation to explore and understand the BattleShip Bot in detail.\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 1834,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(Button, {\n      variant: \"contained\",\n      color: \"primary\",\n      href: \"https://drive.google.com/uc?export=download&id=1lzJLerHY6IB5U9nSyc3LxcWD01hFUd46\",\n      startIcon: /*#__PURE__*/_jsxDEV(GetAppIcon, {}, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1841,\n        columnNumber: 28\n      }, this),\n      sx: {\n        marginTop: '1rem'\n      },\n      download: \"BattleShip-main.zip\",\n      children: \"Download Full Code\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 1837,\n      columnNumber: 13\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 1832,\n    columnNumber: 9\n  }, this);\n};\n_c7 = CodeAccessibility;\nexport default BattleShipBot;\nvar _c, _c2, _c3, _c4, _c5, _c6, _c7;\n$RefreshReg$(_c, \"BattleShipBot\");\n$RefreshReg$(_c2, \"ProjectOverview\");\n$RefreshReg$(_c3, \"YourApproach\");\n$RefreshReg$(_c4, \"TechnicalImplementation\");\n$RefreshReg$(_c5, \"Results\");\n$RefreshReg$(_c6, \"LearningsReflections\");\n$RefreshReg$(_c7, \"CodeAccessibility\");","map":{"version":3,"names":["React","Box","Typography","IconButton","Grid","Button","ArrowBackIcon","LandscapeOverlay","useNavigate","Starfield","FileTreeItem","GetAppIcon","jsxDEV","_jsxDEV","style","container","padding","backgroundColor","color","minHeight","display","flexDirection","alignItems","justifyContent","maxWidth","marginLeft","marginRight","borderRadius","header","marginBottom","textAlign","fontSize","paragraph","lineHeight","featureBox","marginTop","featureHeading","fontWeight","backButton","position","top","left","zIndex","codeSnippet","link","textDecoration","filesData","name","code","BattleShipBot","_s","navigate","handleBack","sx","children","fileName","_jsxFileName","lineNumber","columnNumber","onClick","spacing","ProjectOverview","YourApproach","TechnicalImplementation","Results","LearningsReflections","CodeAccessibility","_c","item","xs","variant","_c2","_c3","map","fileData","_c4","_c5","_c6","href","startIcon","download","_c7","$RefreshReg$"],"sources":["/Users/raethexn/Documents/GitHub/AnthonyMercadante.github.io/src/pages/BattleShipBot/BattleShipBot.tsx"],"sourcesContent":["import React from 'react';\nimport { Box, Typography, IconButton, Grid, Button } from '@mui/material';\nimport ArrowBackIcon from '@mui/icons-material/ArrowBack';\nimport LandscapeOverlay from '../../components/LandscapeOverlay';\nimport { useNavigate } from 'react-router-dom';\nimport Starfield from '../../components/Starfield';\nimport FileTreeItem from '../../components/FileTreeItem';\nimport GetAppIcon from '@mui/icons-material/GetApp';\n\nconst style = {\n    container: {\n        padding: '3rem',\n        backgroundColor: 'rgba(0, 0, 0, 0.9)',\n        color: '#E0E0E0',\n        minHeight: '100vh',\n        display: 'flex',\n        flexDirection: 'column',\n        alignItems: 'center',\n        justifyContent: 'center',\n        maxWidth: '900px',\n        marginLeft: 'auto',\n        marginRight: 'auto',\n        borderRadius: '12px',\n        '@media (max-width: 600px)': {\n            maxWidth: '100%',\n            padding: '1rem',\n        },\n    },\n    header: {\n        marginBottom: '2rem',\n        textAlign: 'center',\n        fontSize: '2rem',\n        color: '#FFFFFF',\n    },\n    paragraph: {\n        marginBottom: '1rem',\n        textAlign: 'left',\n        lineHeight: '1.6',\n    },\n    featureBox: {\n        marginTop: '4rem',\n        textAlign: 'left',\n    },\n    featureHeading: {\n        marginBottom: '1rem',\n        fontSize: '1.5rem',\n        fontWeight: 'bold',\n        color: '#FFFFFF',\n    },\n    backButton: {\n        position: 'absolute',\n        top: '20px',\n        left: '20px',\n        zIndex: 1,\n    },\n    codeSnippet: {\n        backgroundColor: '#333',\n        color: '#ddd',\n        padding: '1rem',\n        borderRadius: '8px',\n        fontSize: '.1rem',\n    },\n    link: {\n        color: '#0a84ff',\n        textDecoration: 'none',\n        '&:hover': {\n            textDecoration: 'underline',\n        },\n    }\n};\n\nconst filesData = [\n    {\n        name: \"BattleShip\",\n        code: `import BattleShipAPI.BattleShipAPI;\n        public class BattleShip {\n            public static void main(String[] args) {\n        \n        \n                final int NUMBEROFGAMES = 10000;\n                System.out.println(BattleShipAPI.getVersion());\n                BattleShipAPI battleShip = new BattleShipAPI(NUMBEROFGAMES, new BattleShipAI());\n                int [] gameResults = battleShip.run();\n        \n                battleShip.reportResults();\n            }\n        }`,\n    },\n    {\n        name: \"BattleShipAI\",\n        code: `import BattleShipAPI.*;\n\n        import java.awt.Point;\n        import java.util.*;\n        \n        /**\n         * BattleShipAI is an implementation of a Battleship game bot.\n         * It uses a combination of probabilistic and targeted strategies\n         * to play Battleship against an opponent.\n         *\n         * @author - Anthony Mercadante\n         * Notes:\n         */\n        public class BattleShipAI implements BattleShipBot {\n            private int gameSize;  // Size of the game board (number of cells in one dimension)\n            private BattleShipAPI battleShip;  // Instance of the battleship game interface\n            private Random random;  // Random number generator for making random decisions\n            private CellState[][] board;  // Representation of the game board's current state\n            private boolean targetMode;  // Flag to indicate whether the bot is in target mode (targeting a specific ship)\n            private Point lastHit;  // The last successful hit coordinate\n            private Map<Point, Double> probabilityMap;  // Map to hold the probability of each cell containing a ship\n            private int[] initialShipSizes;  // Array holding the initial sizes of the ships\n            private Set<Integer> sunkShipSizes;  // Set of sizes of ships that have been sunk\n            private final List<Point> hitList = new ArrayList<>();  // List of points where the bot has successfully hit ships\n            private Boolean shipOrientation;  // Current assumption of the target ship's orientation (null if unknown)\n            private boolean[][] impossibleCells;  // Grid to mark cells where ships cannot possibly be located\n            private boolean[][] potentialCells;  // Grid to mark cells with potential to have ships based on game logic\n            private Map<Point, Set<Point>> shipGraph;  // Graph representing connections between hit cells on a ship\n            private PriorityQueue<CellProbability> probabilityQueue;  // Priority queue to manage cells based on their hit probability\n            private int[][] shipPlacementFrequency;  // Grid to track the frequency of ship placement in each cell across games\n        \n        \n            /**\n             * Initializes the TitanBot with the given BattleShip2 game instance.\n             * This method sets up the initial game state, including the game board,\n             * probability structures, and other strategic elements.\n             *\n             * @param b The BattleShip2 game instance that this bot will be playing.\n             */\n            @Override\n            public void initialize(BattleShipAPI b) {\n                battleShip = b;  // Sets the current BattleShip2 instance\n                gameSize = BattleShipAPI.BOARD_SIZE;  // Initializes the size of the game board\n                random = new Random(0xAAAAAAAA);  // Initializes the random number generator with a seed\n        \n                // Initialize the board state to empty\n                board = new CellState[gameSize][gameSize];\n                for (int i = 0; i < gameSize; i++) {\n                    for (int j = 0; j < gameSize; j++) {\n                        board[i][j] = CellState.Empty;\n                    }\n                }\n        \n                probabilityMap = new HashMap<>();  // Initializes the map for storing cell probabilities\n                sunkShipSizes = new HashSet<>();   // Initializes the set to track sizes of sunk ships\n        \n                // Initialize other strategic elements\n                targetMode = false;  // Initially not in target mode\n                lastHit = null;  // No last hit at the start\n                initialShipSizes = b.getShipSizes();  // Stores the initial sizes of the ships in the game\n                impossibleCells = new boolean[gameSize][gameSize];  // Grid to mark cells where ships cannot be located\n                potentialCells = new boolean[gameSize][gameSize];  // Grid to mark potential cells for ships\n                probabilityQueue = new PriorityQueue<>();  // Priority queue for managing cells based on probability\n                shipGraph = new HashMap<>();  // Graph to connect hits on the same ship\n                shipPlacementFrequency = new int[gameSize][gameSize]; // Tracks ship placement frequency across games\n            }\n        \n        \n        \n            /**\n             * Executes a firing action in the Battleship game.\n             * This method decides the next shot based on the current game state,\n             * utilizing different strategies depending on whether it's early in the game,\n             * in target mode (focusing on a specific ship), or otherwise.\n             * It updates the game state based on the shot's outcome.\n             */\n            @Override\n            public void fireShot() {\n                // Update the status of sunk ships and the probability map for the board\n                updateSunkShips();\n                updateProbabilityMap();\n        \n                Point shot;\n        \n                // Determine the next shot based on game phase and mode\n                if (isEarlyGame()) {\n                    // Use a probabilistic approach in the early game, considering historical data\n                    shot = getNextProbabilisticShot();\n                } else if (targetMode) {\n                    // In target mode, focus on sinking the currently targeted ship\n                    shot = getNextTargetShot();\n                } else {\n                    // Default to a targeted shot strategy outside early game and not in target mode\n                    shot = getTargetedShot();\n                }\n        \n                // Fire the shot and update the board state based on the result\n                boolean hit = battleShip.shoot(shot);\n                board[shot.x][shot.y] = hit ? CellState.Hit : CellState.Miss;\n        \n                // Handle the outcome of the shot\n                if (hit) {\n                    // If a hit, add to hit list, update target mode and related strategies\n                    hitList.add(shot);\n                    lastHit = shot;\n                    targetMode = true;\n                    updateTargetMode();\n                    updateShipGraph(shot);\n                } else if (targetMode && shipOrientation != null) {\n                    // Reset target mode if in target mode but the shot was a miss\n                    resetTargetMode();\n                }\n        \n                // If any ships were sunk, update probability and reset target mode\n                if (battleShip.numberOfShipsSunk() > 0) {\n                    updateProbabilityAfterSinking();\n                    resetTargetMode();\n                }\n            }\n        \n        \n            /**\n             * Returns the author information of this BattleShipAI class.\n             * This method is used to identify the creator of the bot.\n             *\n             * @return A string containing the name of the author and their designation.\n             */\n            @Override\n            public String getAuthors() {\n                return \"Anthony Mercadante (Software Development Student)\";\n            }\n        \n        \n        \n            /**\n             * Determines the next shot using a probabilistic approach based on the frequency of ship placements.\n             * This method iterates over the game board and selects the cell with the highest frequency of having a ship\n             * based on historical data. If no such cell is found, it defaults to a random shot.\n             *\n             * @return The point (coordinates) on the board where the next shot is to be fired.\n             */\n            private Point getNextProbabilisticShot() {\n                // Use shipPlacementFrequency to adjust your shot selection\n                Point selectedShot = null;\n                int maxFrequency = 0;\n                for (int x = 0; x < gameSize; x++) {\n                    for (int y = 0; y < gameSize; y++) {\n                        if (board[x][y] == CellState.Empty && shipPlacementFrequency[x][y] > maxFrequency) {\n                            maxFrequency = shipPlacementFrequency[x][y];\n                            selectedShot = new Point(x, y);\n                        }\n                    }\n                }\n                // Returns the most probable shot; if none is found, defaults to a random shot\n                return selectedShot != null ? selectedShot : randomShot();\n            }\n        \n        \n        \n            /**\n             * Updates the ship graph based on the latest hit.\n             * This method adds the hit point to the ship graph and establishes connections to adjacent hits,\n             * effectively mapping the parts of a ship that have been hit. This graph aids in tracking the hit\n             * sections of ships and determining their orientation.\n             *\n             * @param hit The point on the board where the latest hit occurred.\n             */\n            private void updateShipGraph(Point hit) {\n                // Add the hit point to the graph with an empty set of connections if not already present\n                shipGraph.putIfAbsent(hit, new HashSet<>());\n        \n                // Directions to check for adjacent hits: Up, Down, Left, Right\n                int[][] directions = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};\n        \n                for (int[] dir : directions) {\n                    int adjacentRow = hit.x + dir[0];\n                    int adjacentCol = hit.y + dir[1];\n                    Point adjacentPoint = new Point(adjacentRow, adjacentCol);\n        \n                    // Check if the adjacent cell is a hit and within the board bounds\n                    if (isValidCoordinate(adjacentRow, adjacentCol) && board[adjacentRow][adjacentCol] == CellState.Hit) {\n                        // Connect the current hit with the adjacent hit in the graph\n                        shipGraph.get(hit).add(adjacentPoint);\n        \n                        // Also connect the adjacent hit with the current hit\n                        shipGraph.putIfAbsent(adjacentPoint, new HashSet<>());\n                        shipGraph.get(adjacentPoint).add(hit);\n                    }\n                }\n            }\n        \n        \n            /**\n             * Checks if the given row and column coordinates are valid within the game board.\n             * A coordinate is considered valid if it lies within the bounds of the game board,\n             * which is determined by the gameSize.\n             *\n             * @param row The row coordinate to be checked.\n             * @param col The column coordinate to be checked.\n             * @return true if the coordinate is within the game board; false otherwise.\n             */\n            private boolean isValidCoordinate(int row, int col) {\n                // Check if both row and column are within the bounds of the game board\n                return row >= 0 && row < gameSize && col >= 0 && col < gameSize;\n            }\n        \n        \n        \n            /**\n             * Updates the record of sunk ships based on the current state of the game.\n             * This method compares the initial ship sizes with the current ship sizes\n             * reported by the game. If a ship size from the initial list is no longer\n             * present in the current game state, it is marked as sunk.\n             */\n            private void updateSunkShips() {\n                // Fetch the current sizes of ships remaining in the game\n                int[] currentShipSizes = battleShip.getShipSizes();\n        \n                // Iterate through the initial sizes of ships\n                for (int size : initialShipSizes) {\n                    // If a size from the initial list is not in the current list, it's sunk\n                    if (arrayDoesNotContain(currentShipSizes, size)) {\n                        sunkShipSizes.add(size);  // Mark the ship size as sunk\n                    }\n                }\n            }\n        \n        \n            /**\n             * Checks if the provided array does not contain the specified value.\n             * This utility method iterates through the array and compares each element\n             * to the given value. It is primarily used to determine if a ship of a certain size\n             * has been sunk by checking against the current array of ship sizes.\n             *\n             * @param array The array of integers to be checked.\n             * @param value The value to check for in the array.\n             * @return true if the value is not found in the array; false otherwise.\n             */\n            private boolean arrayDoesNotContain(int[] array, int value) {\n                // Iterate through each element in the array\n                for (int i : array) {\n                    // If the current element equals the value, return false (value is found)\n                    if (i == value) {\n                        return false;\n                    }\n                }\n                // Return true if the value is not found in the array\n                return true;\n            }\n        \n        \n        \n            /**\n             * Determines the next shot in target mode, focusing on sinking a specific ship.\n             * This method first updates the ship's orientation based on recent hits. If the orientation\n             * is known, it attempts to get the next shot inline with the identified orientation. If the orientation\n             * is unknown or the next inline shot is not valid, it selects a high-probability shot around the last hit.\n             * As a fallback, it resorts to a random shot if no suitable target is identified.\n             *\n             * @return The point (coordinates) on the board where the next shot is to be fired.\n             */\n            private Point getNextTargetShot() {\n                // Update the orientation of the target ship based on recent hits\n                updateShipOrientationBasedOnHits();\n        \n                // Attempt to get the next shot inline with the ship's orientation, if known\n                Point nextShot = (shipOrientation != null) ? getNextShotInLineBasedOnOrientation() : null;\n        \n                // If inline shot is not valid or orientation is unknown, prioritize high-probability cells around the last hit\n                if (nextShot == null || !isValidShot(nextShot)) {\n                    nextShot = getHighProbabilityShotAroundLastHit();\n                }\n        \n                // Fallback to a random shot if no suitable shot is identified\n                return (nextShot != null && isValidShot(nextShot)) ? nextShot : randomShot();\n            }\n        \n        \n            /**\n             * Selects the high probability shot around the last hit point.\n             * This method identifies potential target points adjacent to the last hit and\n             * evaluates their probability of containing a ship. The method selects the point\n             * with the highest probability as the next shot, considering only valid shots.\n             * It is used when the bot is in target mode and looking to efficiently sink a ship.\n             *\n             * @return The point with the highest probability around the last hit, or null if no valid targets are found.\n             */\n            private Point getHighProbabilityShotAroundLastHit() {\n                // Return null if there hasn't been a hit yet\n                if (lastHit == null) return null;\n        \n                // Get a list of points adjacent to the last hit\n                List<Point> potentialTargets = getAdjacentPoints(lastHit);\n                double maxProbability = 0.0;\n                Point bestShot = null;\n        \n                // Iterate through potential targets to find the one with the highest probability\n                for (Point target : potentialTargets) {\n                    double prob = probabilityMap.getOrDefault(target, 0.0);\n                    // Update the best shot if the current target has a higher probability and is a valid shot\n                    if (prob > maxProbability && isValidShot(target)) {\n                        maxProbability = prob;\n                        bestShot = target;\n                    }\n                }\n        \n                // Return the point with the highest probability as the best shot\n                return bestShot;\n            }\n        \n        \n            /**\n             * Retrieves a list of points adjacent to a given point on the game board.\n             * This method calculates the points that are directly up, down, left, and right\n             * of the provided point, considering only valid coordinates within the game board.\n             * It's utilized in strategies that require knowledge of surrounding cells, such as\n             * determining potential next shots around a hit.\n             *\n             * @param p The point for which adjacent points are to be found.\n             * @return A list of points adjacent to the given point, filtered for valid game board coordinates.\n             */\n            private List<Point> getAdjacentPoints(Point p) {\n                List<Point> adjacentPoints = new ArrayList<>();\n                // Array defining the four directions: Up, Down, Left, Right\n                int[][] directions = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};\n        \n                // Iterate through each direction to find adjacent points\n                for (int[] dir : directions) {\n                    int newRow = p.x + dir[0];\n                    int newCol = p.y + dir[1];\n        \n                    // Add the point to the list if it is a valid coordinate on the board\n                    if (isValidCoordinate(newRow, newCol)) {\n                        adjacentPoints.add(new Point(newRow, newCol));\n                    }\n                }\n        \n                // Return the list of adjacent, valid points\n                return adjacentPoints;\n            }\n        \n        \n        \n            /**\n             * Updates the assumed orientation of the currently targeted ship based on the list of hits.\n             * This method analyzes the hit points recorded in the hitList to determine if the ship is placed\n             * horizontally or vertically. The orientation is set to horizontal if all hits are in the same row,\n             * vertical if they are in the same column, and remains unclear (null) if the hits do not align\n             * either horizontally or vertically.\n             */\n            private void updateShipOrientationBasedOnHits() {\n                // If there are less than two hits, orientation cannot be determined\n                if (hitList.size() < 2) {\n                    shipOrientation = null;\n                    return;\n                }\n        \n                boolean isHorizontal = true;\n                boolean isVertical = true;\n                // Take the coordinates of the first hit as reference points\n                int firstRow = hitList.get(0).x;\n                int firstCol = hitList.get(0).y;\n        \n                // Iterate through the hitList to determine the ship's orientation\n                for (Point hit : hitList) {\n                    if (hit.x != firstRow) {\n                        isVertical = false;  // Different rows imply it's not vertical\n                    }\n                    if (hit.y != firstCol) {\n                        isHorizontal = false; // Different columns imply it's not horizontal\n                    }\n                }\n        \n                // Set the shipOrientation based on the findings\n                if (isHorizontal && !isVertical) {\n                    shipOrientation = true; // The ship is oriented horizontally\n                } else if (!isHorizontal && isVertical) {\n                    shipOrientation = false; // The ship is oriented vertically\n                } else {\n                    shipOrientation = null; // Orientation remains unclear\n                }\n            }\n        \n        \n            /**\n             * Determines the next shot based on the assumed orientation of the targeted ship.\n             * This method calculates the next shot point either to the right or left of the last hit\n             * for a horizontally oriented ship, or above or below the last hit for a vertically oriented ship.\n             * The method only considers valid shots within the game board bounds.\n             *\n             * @return The next shot point based on the ship's orientation, or null if no valid shot is found.\n             */\n            private Point getNextShotInLineBasedOnOrientation() {\n                // Return null if orientation is unknown or there are no hits to base the decision on\n                if (shipOrientation == null || hitList.isEmpty()) {\n                    return null;\n                }\n        \n                // Get the first and last hit points from the hit list\n                Point firstHit = hitList.get(0);\n                Point lastHit = hitList.get(hitList.size() - 1);\n        \n                if (shipOrientation) {\n                    // If the ship is oriented horizontally, check for shots to the right and left\n                    Point shotRight = new Point(lastHit.x, lastHit.y + 1);\n                    if (isValidShot(shotRight)) {\n                        return shotRight;\n                    }\n        \n                    Point shotLeft = new Point(firstHit.x, firstHit.y - 1);\n                    if (isValidShot(shotLeft)) {\n                        return shotLeft;\n                    }\n                } else {\n                    // If the ship is oriented vertically, check for shots above and below\n                    Point shotDown = new Point(lastHit.x + 1, lastHit.y);\n                    if (isValidShot(shotDown)) {\n                        return shotDown;\n                    }\n        \n                    Point shotUp = new Point(firstHit.x - 1, firstHit.y);\n                    if (isValidShot(shotUp)) {\n                        return shotUp;\n                    }\n                }\n        \n                // Return null if no valid shot is found based on the ship's orientation\n                return null;\n            }\n        \n        \n        \n            /**\n             * Checks if a given shot is valid on the game board.\n             * This method verifies that the shot is within the boundaries of the game board\n             * and targets a cell that has not been shot at yet (i.e., the cell is in an 'Empty' state).\n             * It is used to ensure that the bots shot selections are valid and executable within the game.\n             *\n             * @param p The point representing the coordinates of the shot to be validated.\n             * @return true if the shot is valid (within the game board and targeting an empty cell); false otherwise.\n             */\n            private boolean isValidShot(Point p) {\n                // Check if the point is within the game board and targets an empty cell\n                return p.x >= 0 && p.x < gameSize && p.y >= 0 && p.y < gameSize && board[p.x][p.y] == CellState.Empty;\n            }\n        \n        \n        \n            /**\n             * Updates the probability map for the entire game board.\n             * This method resets the current probabilities and recalculates them for each cell\n             * based on the potential presence of unsunk ships. It considers the sizes of the ships\n             * that are still in play and updates the probabilities for each cell being part of an unsunk ship.\n             * The method is crucial for the bots decision-making process, as it guides the shot selection\n             * by identifying the most probable locations of the remaining enemy ships.\n             */\n            private void updateProbabilityMap() {\n                // Reset the probability map to zero for all points\n                probabilityMap.replaceAll((p, v) -> 0.0);\n        \n                // Iterate through all ship sizes still in play\n                for (int shipSize : battleShip.getShipSizes()) {\n                    // Skip updating probabilities for sunk ship sizes\n                    if (!sunkShipSizes.contains(shipSize)) {\n                        // Update probabilities for each cell on the board\n                        for (Point point : probabilityMap.keySet()) {\n                            // Only update probabilities for empty cells\n                            if (board[point.x][point.y] == CellState.Empty) {\n                                // Calculate the probability for the current cell and ship size\n                                double prob = calculateProbabilityForShipSize(point.x, point.y, shipSize);\n                                // Update the probability map with the new calculated probability\n                                probabilityMap.put(point, probabilityMap.get(point) + prob);\n                            }\n                        }\n                    }\n                }\n            }\n        \n        \n        \n            /**\n             * Calculates the probability of a ship of a given size being placed horizontally at a specified location.\n             * This method iterates through each cell starting from the specified row and column, extending horizontally\n             * for the length of the ship. It checks if the placement is possible (not marked as impossible) and calculates\n             * the probability based on the size of the game board. If any part of the ship placement is marked as impossible,\n             * the probability is set to zero.\n             *\n             * @param row The starting row coordinate for the potential ship placement.\n             * @param col The starting column coordinate for the potential ship placement.\n             * @param shipSize The size of the ship to be placed.\n             * @return The probability of being able to place the ship at the specified location horizontally.\n             */\n            private double calculateHorizontalProbability(int row, int col, int shipSize) {\n                double prob = 1.0;  // Initialize probability\n        \n                // Iterate through each cell horizontally from the starting point for the length of the ship\n                for (int i = 0; i < shipSize; i++) {\n                    // Check if the cell is marked as impossible for ship placement\n                    if (impossibleCells[row][col + i]) {\n                        return 0.0;  // Return zero probability if any part of the placement is impossible\n                    }\n                    // Multiply the probability by a factor (adjust this based on game logic and board size)\n                    prob *= (1.0 / (gameSize * gameSize));\n                }\n        \n                return prob;  // Return the calculated probability\n            }\n        \n        \n            /**\n             * Calculates the probability of a ship of a given size being placed vertically at a specified location.\n             * This method iterates through each cell starting from the specified row and column, extending vertically\n             * for the length of the ship. It assesses whether placement is feasible (not in an impossible cell) and\n             * calculates the probability based on the size of the game board. If any part of the ship placement is marked\n             * as impossible, the probability is set to zero.\n             *\n             * @param row The starting row coordinate for the potential ship placement.\n             * @param col The starting column coordinate for the potential ship placement.\n             * @param shipSize The size of the ship to be placed.\n             * @return The probability of being able to place the ship at the specified location vertically.\n             */\n            private double calculateVerticalProbability(int row, int col, int shipSize) {\n                double prob = 1.0;  // Initialize probability\n        \n                // Iterate through each cell vertically from the starting point for the length of the ship\n                for (int i = 0; i < shipSize; i++) {\n                    // Check if the cell is marked as impossible for ship placement\n                    if (impossibleCells[row + i][col]) {\n                        return 0.0;  // Return zero probability if any part of the placement is impossible\n                    }\n                    // Multiply the probability by a factor (adjust this based on game logic and board size)\n                    prob *= (1.0 / (gameSize * gameSize));\n                }\n        \n                return prob;  // Return the calculated probability\n            }\n        \n        \n        \n            /**\n             * Determines whether a ship of a given size can be placed horizontally at a specified location.\n             * This method checks if the ship can fit horizontally starting from the specified row and column,\n             * ensuring that it doesn't extend beyond the game board's boundaries. It also verifies that each\n             * cell along the ship's length is empty and not marked as an impossible location for ship placement.\n             *\n             * @param row The row coordinate for the starting point of the ship placement.\n             * @param col The column coordinate for the starting point of the ship placement.\n             * @param shipSize The size of the ship to be placed.\n             * @return true if the ship can be placed horizontally at the specified location; false otherwise.\n             */\n            private boolean canPlaceShipHorizontally(int row, int col, int shipSize) {\n                // Check if the ship extends beyond the game board's boundaries\n                if (col + shipSize > gameSize) return false;\n        \n                // Iterate through each cell where the ship would be placed\n                for (int i = 0; i < shipSize; i++) {\n                    // Check if each cell is empty and not marked as impossible for ship placement\n                    if (board[row][col + i] != CellState.Empty || impossibleCells[row][col + i]) {\n                        return false;  // Return false if any cell is occupied or impossible\n                    }\n                }\n        \n                return true;  // Return true if the ship can be placed horizontally\n            }\n        \n        \n            /**\n             * Determines whether a ship of a given size can be placed vertically at a specified location.\n             * This method checks if the ship can fit vertically starting from the specified row and column,\n             * ensuring that it doesn't extend beyond the game board's boundaries. It also verifies that each\n             * cell along the ship's length is empty and not marked as an impossible location for ship placement.\n             *\n             * @param row The row coordinate for the starting point of the ship placement.\n             * @param col The column coordinate for the starting point of the ship placement.\n             * @param shipSize The size of the ship to be placed.\n             * @return true if the ship can be placed vertically at the specified location; false otherwise.\n             */\n            private boolean canPlaceShipVertically(int row, int col, int shipSize) {\n                // Check if the ship extends beyond the game board's boundaries\n                if (row + shipSize > gameSize) return false;\n        \n                // Iterate through each cell where the ship would be placed\n                for (int i = 0; i < shipSize; i++) {\n                    // Check if each cell is empty and not marked as impossible for ship placement\n                    if (board[row + i][col] != CellState.Empty || impossibleCells[row + i][col]) {\n                        return false;  // Return false if any cell is occupied or impossible\n                    }\n                }\n        \n                return true;  // Return true if the ship can be placed vertically\n            }\n        \n        \n        \n            /**\n             * Rebuilds the priority queue based on the current probability map.\n             * This method clears the existing probability queue and repopulates it with the points\n             * from the probability map, considering only those points that are still empty on the board.\n             * Each point is added along with its associated probability value. The priority queue is\n             * used for efficient selection of the next shot based on the calculated probabilities.\n             */\n            private void rebuildProbabilityQueue() {\n                // Clear the existing probability queue\n                probabilityQueue.clear();\n        \n                // Iterate through each entry in the probability map\n                for (Map.Entry<Point, Double> entry : probabilityMap.entrySet()) {\n                    Point point = entry.getKey();\n                    // Only add points to the queue that are empty on the board\n                    if (board[point.x][point.y] == CellState.Empty) {\n                        // Add the point and its probability to the queue\n                        probabilityQueue.add(new CellProbability(point, entry.getValue()));\n                    }\n                }\n            }\n        \n        \n        \n            /**\n             * Generates a random shot within the bounds of the game board.\n             * This method selects a random point on the board, ensuring that the chosen cell\n             * is empty (i.e., it has not been shot at yet). It continues to select random points\n             * until an empty cell is found, thereby guaranteeing a valid shot.\n             *\n             * @return A Point object representing the coordinates of the randomly selected shot.\n             */\n            private Point randomShot() {\n                Point shot;\n                // Continuously generate random points until an empty cell is found\n                do {\n                    // Create a point with random coordinates within the game board\n                    shot = new Point(random.nextInt(gameSize), random.nextInt(gameSize));\n                } while (board[shot.x][shot.y] != CellState.Empty);  // Ensure the cell is empty\n        \n                return shot;  // Return the valid random shot\n            }\n        \n        \n            /**\n             * Resets the targeting mode to its initial state.\n             * This method is called when the bot needs to exit target mode, typically after sinking a ship\n             * or when it needs to reevaluate its strategy. It resets various attributes related to target mode,\n             * including disabling the mode, clearing the last hit point, clearing the list of hit points, and\n             * resetting the assumed orientation of the targeted ship.\n             */\n            private void resetTargetMode() {\n                targetMode = false;          // Disable target mode\n                lastHit = null;              // Clear the last hit point\n                hitList.clear();             // Clear the list of hit points\n                shipOrientation = null;      // Reset the assumed ship orientation\n            }\n        \n        \n            /**\n             * Updates the target mode by reassessing the ship's orientation based on the hit list.\n             * This method is invoked when there are multiple hits in the hit list to determine\n             * the orientation of the ship being targeted. It sets the shipOrientation attribute\n             * based on the alignment of the first two hits: horizontal if they are in the same row,\n             * or vertical if they are in the same column.\n             */\n            private void updateTargetMode() {\n                // Check if there are at least two hits to determine the orientation\n                if (!hitList.isEmpty() && hitList.size() > 1) {\n                    Point firstHit = hitList.get(0);  // Get the first hit point\n                    Point secondHit = hitList.get(1); // Get the second hit point\n        \n                    // Determine the orientation: true for horizontal, false for vertical\n                    shipOrientation = (firstHit.x == secondHit.x);\n                }\n            }\n        \n        \n            /**\n             * Updates the probability map after a ship has been sunk.\n             * This method iterates over each point in the hit list (which represents parts of the sunk ship)\n             * and marks adjacent cells as impossible locations for other ships. It also adjusts the probabilities\n             * for cells around the sunk ship, reflecting the updated game state where no other ship can occupy\n             * those adjacent cells. This is essential for refining the probability map based on known ship placements.\n             */\n            private void updateProbabilityAfterSinking() {\n                // Iterate over each part of the sunk ship\n                for (Point sunkShipPart : hitList) {\n                    // Mark cells adjacent to each part of the sunk ship as impossible for ship placement\n                    markAdjacentAsImpossible(sunkShipPart.x, sunkShipPart.y);\n        \n                    // Adjust probability for cells around each part of the sunk ship\n                    updateAdjacentProbabilities(sunkShipPart.x, sunkShipPart.y);\n                }\n            }\n        \n        \n            /**\n             * Updates the probabilities of cells adjacent to a given coordinate on the game board.\n             * This method is used following events that change the game state, such as sinking a ship,\n             * to adjust the probabilities of nearby cells. It calculates new probabilities for cells in all\n             * four cardinal directions (up, down, left, right) adjacent to the specified cell, provided they\n             * are within the game board's boundaries and are empty.\n             *\n             * @param row The row coordinate of the central point from which to update adjacent probabilities.\n             * @param col The column coordinate of the central point from which to update adjacent probabilities.\n             */\n            private void updateAdjacentProbabilities(int row, int col) {\n                // Define the four cardinal directions\n                int[][] directions = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\n        \n                // Iterate through each direction to update adjacent cell probabilities\n                for (int[] dir : directions) {\n                    int newRow = row + dir[0];\n                    int newCol = col + dir[1];\n                    Point adjacentPoint = new Point(newRow, newCol);\n        \n                    // Check if the adjacent cell is within the game board and is empty\n                    if (isValidCoordinate(newRow, newCol) && board[newRow][newCol] == CellState.Empty) {\n                        // Calculate and update the probability for the adjacent cell\n                        double newProbability = calculateCellProbability(newRow, newCol);\n                        probabilityMap.put(adjacentPoint, newProbability);\n                    }\n                }\n            }\n        \n        \n        \n            /**\n             * Marks cells adjacent to a given coordinate as impossible locations for ship placement.\n             * This method is typically used after a ship has been sunk to mark the surrounding cells,\n             * which cannot contain any part of another ship. It assesses cells in all four cardinal\n             * directions (up, down, left, right) adjacent to the specified cell and marks them as impossible\n             * if they are within the game board's boundaries.\n             *\n             * @param row The row coordinate of the central point from which to mark adjacent cells.\n             * @param col The column coordinate of the central point from which to mark adjacent cells.\n             */\n            private void markAdjacentAsImpossible(int row, int col) {\n                // Define the four cardinal directions\n                int[][] directions = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\n        \n                // Iterate through each direction to mark adjacent cells as impossible\n                for (int[] dir : directions) {\n                    int newRow = row + dir[0];\n                    int newCol = col + dir[1];\n        \n                    // Check if the adjacent cell is within the game board boundaries\n                    if (isValidCoordinate(newRow, newCol)) {\n                        // Mark the cell as impossible for ship placement\n                        impossibleCells[newRow][newCol] = true;\n                    }\n                }\n            }\n        \n        \n        \n            /**\n             * Calculates the probability of a cell being occupied by a part of a ship.\n             * This method considers both horizontal and vertical placement possibilities for all\n             * unsunk ship sizes. It sums up the probabilities for each ship size that can be placed\n             * at the given cell, considering the cell's current state and the game's constraints.\n             * Cells marked as impossible for ship placement immediately return a probability of zero.\n             *\n             * @param row The row coordinate of the cell for which to calculate the probability.\n             * @param col The column coordinate of the cell for which to calculate the probability.\n             * @return The calculated probability of the cell being occupied by a ship.\n             */\n            private double calculateCellProbability(int row, int col) {\n                // If the cell is marked as impossible, its probability is zero\n                if (impossibleCells[row][col]) {\n                    return 0.0;\n                }\n        \n                double probability = 0.0;  // Initialize probability\n        \n                // Iterate through the sizes of unsunk ships\n                for (int shipSize : battleShip.getShipSizes()) {\n                    // Skip calculation for ship sizes that are already sunk\n                    if (sunkShipSizes.contains(shipSize)) {\n                        continue;\n                    }\n        \n                    // Add probability for horizontal placement if possible\n                    if (canPlaceShipHorizontally(row, col, shipSize)) {\n                        probability += (1.0 / shipSize);\n                    }\n        \n                    // Add probability for vertical placement if possible\n                    if (canPlaceShipVertically(row, col, shipSize)) {\n                        probability += (1.0 / shipSize);\n                    }\n                }\n        \n                return probability;  // Return the summed probability\n            }\n        \n        \n            /**\n             * Determines whether the current state of the game can be considered as the early game phase.\n             * This method assesses the stage of the game based on the number of hits and total shots made.\n             * It uses a percentage threshold of the game board to define the early game, along with a dynamic\n             * threshold based on the sizes of the ships. This assessment helps in deciding which strategy to\n             * apply during the game - different strategies might be more effective in early or later stages.\n             *\n             * @return true if the game is still in its early stages, false otherwise.\n             */\n            private boolean isEarlyGame() {\n                int totalHits = hitList.size();  // Count of total hits made so far\n                int totalShots = getTotalShots();  // Total number of shots fired so far\n        \n                // Define threshold for considering it as early game based on board size (e.g., 25% of the board)\n                int earlyGamePercentageThreshold = (int) (gameSize * gameSize * 0.25);\n        \n                // Dynamic threshold for hits, based on ship sizes\n                int hitThreshold = determineHitThreshold();\n        \n                // Determine if it's still early game based on the number of shots and hits\n                return totalHits < hitThreshold && totalShots < earlyGamePercentageThreshold;\n            }\n        \n        \n            /**\n             * Determines the hit threshold to help define the early game phase.\n             * This method calculates a dynamic threshold based on the sizes of the ships in the game,\n             * specifically using the size of the smallest ship. The logic assumes that the game moves\n             * out of the early phase after hitting at least half of the smallest ship. This threshold\n             * is used in conjunction with other criteria to determine the game's current stage and\n             * adjust the bots' strategy accordingly.\n             *\n             * @return The dynamically calculated hit threshold based on the smallest ship's size.\n             */\n            private int determineHitThreshold() {\n                // Find the size of the smallest ship in the game\n                int smallestShipSize = findSmallestShipSize();\n        \n                // Calculate the hit threshold as half the size of the smallest ship\n                return smallestShipSize / 2;\n            }\n        \n        \n            /**\n             * Identifies the size of the smallest ship in the game.\n             * This method iterates through the array of initial ship sizes and finds the smallest value.\n             * The smallest ship size is an important factor in various strategic calculations, such as\n             * determining hit thresholds and assessing the game's stage.\n             *\n             * @return The size of the smallest ship in the initial ship sizes array.\n             */\n            private int findSmallestShipSize() {\n                int smallestSize = Integer.MAX_VALUE;  // Initialize with the maximum possible value\n        \n                // Iterate through each ship size\n                for (int size : initialShipSizes) {\n                    // Update the smallestSize if a smaller ship size is found\n                    if (size < smallestSize) {\n                        smallestSize = size;\n                    }\n                }\n        \n                return smallestSize;  // Return the smallest ship size\n            }\n        \n        \n        \n            /**\n             * Calculates the total number of shots fired in the game.\n             * This method iterates over the entire game board and counts the number of cells that\n             * are not in the 'Empty' state, indicating that a shot has been fired at those cells.\n             * It provides an accurate count of all shots made, used in determining the game's stage\n             * and in various strategic decision-making processes.\n             *\n             * @return The total number of shots fired so far in the game.\n             */\n            private int getTotalShots() {\n                int totalShots = 0;  // Initialize the counter for total shots\n        \n                // Iterate through each cell on the game board\n                for (int i = 0; i < gameSize; i++) {\n                    for (int j = 0; j < gameSize; j++) {\n                        // Increment the counter for each cell that is not empty (i.e., a shot has been fired)\n                        if (board[i][j] != CellState.Empty) {\n                            totalShots++;\n                        }\n                    }\n                }\n        \n                return totalShots;  // Return the total number of shots\n            }\n        \n        \n            /**\n             * Calculates the probability of a ship of a specific size being located at a given cell.\n             * This method considers both horizontal and vertical placements of the ship at the specified coordinates.\n             * It calculates the probability based on whether the ship can be placed in those orientations, given the\n             * current state of the game board. The method also adjusts the probability based on adjacent hits and the\n             * potential orientation of ships. If the ship size has already been sunk, it skips the calculation and returns zero.\n             *\n             * @param x The x-coordinate (row) of the cell for probability calculation.\n             * @param y The y-coordinate (column) of the cell for probability calculation.\n             * @param shipSize The size of the ship for which to calculate the probability.\n             * @return The calculated probability of a ship of the given size being at the specified cell.\n             */\n            private double calculateProbabilityForShipSize(int x, int y, int shipSize) {\n                // Skip calculation and return zero if the ship size has already been sunk\n                if (sunkShipSizes.contains(shipSize)) {\n                    return 0.0;\n                }\n        \n                double probability = 0.0;  // Initialize probability\n        \n                // Add to the probability if the ship can be placed horizontally at the cell\n                if (canPlaceShipHorizontally(x, y, shipSize)) {\n                    probability += calculateHorizontalProbability(x, y, shipSize);\n                }\n        \n                // Add to the probability if the ship can be placed vertically at the cell\n                if (canPlaceShipVertically(x, y, shipSize)) {\n                    probability += calculateVerticalProbability(x, y, shipSize);\n                }\n        \n                // Adjust the probability based on adjacent hits and potential ship orientation\n                probability *= adjustProbabilityBasedOnHits(x, y);\n        \n                // Apply additional factors based on patterns or other strategic considerations\n                double patternProbabilityFactor = getPatternProbabilityFactor(x, y, shipSize);\n                probability *= patternProbabilityFactor;\n        \n                return probability;  // Return the final calculated probability\n            }\n        \n        \n            /**\n             * Adjusts the probability of a cell being occupied by a ship based on adjacent hits.\n             * This method increases the probability factor if the cell is adjacent to a hit, considering\n             * potential ship patterns. It checks for hits in all four cardinal directions and identifies\n             * whether the hits form a horizontal or vertical pattern. The probability is adjusted higher\n             * if adjacent hits suggest a possible extension of a ship in those directions. This adjustment\n             * helps in refining the shot selection by taking into account the orientation of partially hit ships.\n             *\n             * @param x The x-coordinate (row) of the cell for which to adjust the probability.\n             * @param y The y-coordinate (column) of the cell for which to adjust the probability.\n             * @return The adjusted probability factor for the cell based on adjacent hits.\n             */\n            private double adjustProbabilityBasedOnHits(int x, int y) {\n                double adjustmentFactor = 1.0;  // Initialize adjustment factor\n        \n                // Flags to track if there are adjacent hits forming horizontal or vertical patterns\n                boolean horizontalHit = false, verticalHit = false;\n        \n                // Check for hits in all four cardinal directions\n                int[][] directions = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};\n                for (int[] dir : directions) {\n                    int adjacentX = x + dir[0];\n                    int adjacentY = y + dir[1];\n        \n                    // Increase probability if the adjacent cell is a hit\n                    if (isValidCoordinate(adjacentX, adjacentY) && board[adjacentX][adjacentY] == CellState.Hit) {\n                        adjustmentFactor *= 1.5;  // Increase factor for cells adjacent to a hit\n        \n                        // Determine if hits form horizontal or vertical patterns\n                        if (dir[0] == 0) horizontalHit = true;  // Horizontal pattern\n                        if (dir[1] == 0) verticalHit = true;   // Vertical pattern\n                    }\n                }\n        \n                // Further adjust probability based on detected hit patterns\n                if (horizontalHit && verticalHit) {\n                    // Hits in multiple directions may suggest proximity to multiple ships\n                    adjustmentFactor *= 1.2;\n                } else if (horizontalHit) {\n                    // Increase probability for horizontal extension if horizontal hits detected\n                    adjustmentFactor *= predictHorizontalExtension(x, y);\n                } else if (verticalHit) {\n                    // Increase probability for vertical extension if vertical hits detected\n                    adjustmentFactor *= predictVerticalExtension(x, y);\n                }\n        \n                return adjustmentFactor;  // Return the adjusted probability factor\n            }\n        \n        \n            /**\n             * Predicts the likelihood of a horizontal extension of a ship from a given cell.\n             * This method adjusts a probability factor based on the state of cells to the left and right\n             * of the given coordinates. It increases the factor if there are hits adjacent to the cell\n             * (suggesting a possible horizontal ship extension), and decreases it if there are misses\n             * (suggesting the absence of a ship in that direction). This probability adjustment aids in\n             * refining the bots targeting strategy, especially when determining the orientation of partially hit ships.\n             *\n             * @param x The x-coordinate (row) of the cell for which to predict the horizontal extension.\n             * @param y The y-coordinate (column) of the cell for which to predict the horizontal extension.\n             * @return The adjusted factor indicating the likelihood of a horizontal ship extension from the cell.\n             */\n            private double predictHorizontalExtension(int x, int y) {\n                double extensionFactor = 1.0;  // Initialize the extension factor\n        \n                // Check for hits or misses to the left of the cell\n                if (y > 0) {\n                    if (board[x][y - 1] == CellState.Hit) extensionFactor *= 1.2; // Increase if there is a hit on the left\n                    if (board[x][y - 1] == CellState.Miss) extensionFactor *= 0.8; // Decrease if there is a miss on the left\n                }\n        \n                // Check for hits or misses to the right of the cell\n                if (y < gameSize - 1) {\n                    if (board[x][y + 1] == CellState.Hit) extensionFactor *= 1.2; // Increase if there is a hit on the right\n                    if (board[x][y + 1] == CellState.Miss) extensionFactor *= 0.8; // Decrease if there is a miss on the right\n                }\n        \n                return extensionFactor;  // Return the probability extension factor\n            }\n        \n        \n        \n            /**\n             * Predicts the likelihood of a vertical extension of a ship from a given cell.\n             * This method adjusts a probability factor based on the state of cells above and below\n             * the given coordinates. It increases the factor if there are hits adjacent to the cell\n             * (suggesting a possible vertical ship extension), and decreases it if there are misses\n             * (suggesting the absence of a ship in that direction). This probability adjustment is\n             * instrumental in refining the bots targeting strategy, particularly when determining\n             * the orientation of partially hit ships.\n             *\n             * @param x The x-coordinate (row) of the cell for which to predict the vertical extension.\n             * @param y The y-coordinate (column) of the cell for which to predict the vertical extension.\n             * @return The adjusted factor indicating the likelihood of a vertical ship extension from the cell.\n             */\n            private double predictVerticalExtension(int x, int y) {\n                double extensionFactor = 1.0;  // Initialize the extension factor\n        \n                // Check for hits or misses above the cell\n                if (x > 0) {\n                    if (board[x - 1][y] == CellState.Hit) extensionFactor *= 1.2; // Increase if there is a hit above\n                    if (board[x - 1][y] == CellState.Miss) extensionFactor *= 0.8; // Decrease if there is a miss above\n                }\n        \n                // Check for hits or misses below the cell\n                if (x < gameSize - 1) {\n                    if (board[x + 1][y] == CellState.Hit) extensionFactor *= 1.2; // Increase if there is a hit below\n                    if (board[x + 1][y] == CellState.Miss) extensionFactor *= 0.8; // Decrease if there is a miss below\n                }\n        \n                return extensionFactor;  // Return the probability extension factor\n            }\n        \n        \n        \n            /**\n             * Calculates an overall pattern probability factor for a cell based on various strategic elements.\n             * This method combines several factors that influence the probability of a ship being at a given cell.\n             * It includes an edge avoidance factor to account for the less likely placement of ships at the edges,\n             * a central concentration factor that increases probabilities towards the center of the board, and\n             * a randomness factor to add variability and unpredictability to the bots' strategy. These combined\n             * factors help in making a more nuanced and effective probability assessment for each cell.\n             *\n             * @param x The x-coordinate (row) of the cell for which to calculate the pattern probability factor.\n             * @param y The y-coordinate (column) of the cell for which to calculate the pattern probability factor.\n             * @param shipSize The size of the ship being considered for the probability calculation.\n             * @return The overall pattern probability factor for the cell.\n             */\n            private double getPatternProbabilityFactor(int x, int y, int shipSize) {\n                // Calculate individual factors influencing the cell's probability\n                double edgeAvoidanceFactor = calculateEdgeAvoidanceFactor(x, y, shipSize);\n                double centralConcentrationFactor = calculateCentralConcentrationFactor(x, y);\n                double randomnessFactor = calculateRandomnessFactor();\n        \n                // Combine the factors to compute the overall pattern probability factor\n                return edgeAvoidanceFactor * centralConcentrationFactor * randomnessFactor;\n            }\n        \n        \n            /**\n             * Calculates the edge avoidance factor for a cell based on its proximity to the nearest edge and the ship size.\n             * This method assesses how close a given cell is to the nearest edge of the game board. The factor is adjusted\n             * based on the size of the ship being considered, with the assumption that larger ships are less likely to be\n             * placed close to the edges. The edge avoidance factor is used as part of the strategy to estimate the probability\n             * of a ship being located at a particular cell, especially for cells near the board's boundaries.\n             *\n             * @param x The x-coordinate (row) of the cell for which to calculate the edge avoidance factor.\n             * @param y The y-coordinate (column) of the cell for which to calculate the edge avoidance factor.\n             * @param shipSize The size of the ship being considered for the calculation.\n             * @return The calculated edge avoidance factor for the cell.\n             */\n            private double calculateEdgeAvoidanceFactor(int x, int y, int shipSize) {\n                // Calculate the cell's distance from the nearest edge\n                int edgeDistance = Math.min(Math.min(x, gameSize - x - 1), Math.min(y, gameSize - y - 1));\n        \n                // Determine the influence of ship size on edge placement\n                double sizeFactor = 1.0 - ((double) shipSize / gameSize);\n        \n                // Combine edge distance and ship size factors to compute the edge avoidance factor\n                return 1.0 - sizeFactor * (1.0 / (edgeDistance + 1));\n            }\n        \n        \n        \n            /**\n             * Calculates the central concentration factor for a cell, increasing its probability based on proximity to the center of the board.\n             * This method computes the cell's distance from the center of the game board and adjusts the probability factor accordingly,\n             * under the assumption that ships are more likely to be placed closer to the center. The central concentration factor is\n             * a part of the overall strategy to refine the probability map, giving more weight to cells near the center of the board.\n             *\n             * @param x The x-coordinate (row) of the cell for which to calculate the central concentration factor.\n             * @param y The y-coordinate (column) of the cell for which to calculate the central concentration factor.\n             * @return The calculated central concentration factor for the cell.\n             */\n            private double calculateCentralConcentrationFactor(int x, int y) {\n                // Determine the center coordinates of the game board\n                int centerX = gameSize / 2;\n                int centerY = gameSize / 2;\n        \n                // Calculate the Manhattan distance from the cell to the center of the board\n                int distanceFromCenter = Math.abs(x - centerX) + Math.abs(y - centerY);\n        \n                // Calculate and return the central concentration factor, increasing as the cell gets closer to the center\n                return 1.0 + 0.5 * (1.0 / (distanceFromCenter + 1));\n            }\n        \n        \n            /**\n             * Generates a randomness factor to introduce variability into the bots decision-making process.\n             * This method calculates a random factor within a defined range to add an element of unpredictability\n             * to the bots' strategy. This randomness helps in avoiding overly predictable patterns in the bots\n             * shot selection and probability assessments, making it more challenging for opponents to anticipate\n             * the bots actions. The randomness factor is integrated into various probability calculations.\n             *\n             * @return A random factor within a specified range (e.g., between 0.8 and 1.2).\n             */\n            private double calculateRandomnessFactor() {\n                // Generate and return a random factor within the range of 0.8 to 1.2\n                return 0.8 + 0.4 * Math.random(); // Random factor between 0.8 and 1.2\n            }\n        \n        \n        \n            /**\n             * Selects the next targeted shot based on updated probability assessments.\n             * This method first rebuilds the probability queue to reflect the latest probabilities\n             * for each cell on the game board. It then selects the cell with the highest probability\n             * of containing a ship, ensuring that the cell is empty (i.e., not already shot at). If no\n             * high probability shots are available, it defaults to a random shot as a fallback strategy.\n             *\n             * @return The point representing the coordinates of the next targeted shot,\n             *         chosen based on the highest probability or randomly if no suitable target is found.\n             */\n            private Point getTargetedShot() {\n                // Rebuild the probability queue to include the latest probabilities\n                rebuildProbabilityQueue();\n        \n                // Stream through the probability queue, filter for empty cells, and select the first highest probability\n                return probabilityQueue.stream()\n                        .filter(cellProb -> board[cellProb.point.x][cellProb.point.y] == CellState.Empty)\n                        .findFirst()\n                        .map(cellProb -> cellProb.point)\n                        .orElseGet(this::randomShot); // Fallback to a random shot if no high probability cells are found\n            }\n        \n        \n        \n            /**\n             * Represents the probability of a cell being occupied by a part of a ship.\n             * This class is used to pair a point on the game board with its corresponding probability score.\n             * It implements the Comparable interface to allow sorting of these objects based on their probability,\n             * facilitating the selection of the most probable shots. The comparison is done in descending order\n             * of probability, meaning higher probabilities come first.\n             */\n            private static class CellProbability implements Comparable<CellProbability> {\n                Point point;          // The point on the game board\n                double probability;   // The probability associated with this point\n        \n                /**\n                 * Constructs a CellProbability object with a specific point and its probability.\n                 *\n                 * @param point The point on the game board.\n                 * @param probability The probability of a ship being at this point.\n                 */\n                public CellProbability(Point point, double probability) {\n                    this.point = point;\n                    this.probability = probability;\n                }\n        \n                /**\n                 * Compares this CellProbability object with another to determine their ordering.\n                 *\n                 * @param other Another CellProbability object to be compared against.\n                 * @return A negative integer, zero, or a positive integer as this object is less than,\n                 *         equal to, or greater than the specified object in terms of probability.\n                 */\n                @Override\n                public int compareTo(CellProbability other) {\n                    // Sort in descending order of probability\n                    return Double.compare(other.probability, this.probability);\n                }\n            }\n        \n        }`,\n    },\n    {\n        name: \"BattleShipAPI.java\",\n        code: `package BattleShipAPI;\n\n        import java.awt.Point;\n        import java.util.ArrayList;\n        import java.util.Iterator;\n        import java.util.Random;\n        \n        public class BattleShipAPI {\n            private static final boolean DEBUGMODE = false;\n            public static final int BOARD_SIZE = 10;\n            public static final int[] SHIP_SIZES = new int[]{5, 4, 3, 2, 2, 1, 1};\n            private int numberOfGames;\n            private int boardSize;\n            private boolean success;\n            private int[] shipSizes;\n            private CellState[][] board;\n            private ArrayList<Ship> ships;\n            private ArrayList<Point> hits;\n            private ArrayList<Point> misses;\n            private Random random = new Random(-1412567296L);\n            private int totalShots;\n            private long timeRequired;\n            private BattleShipBot bot;\n        \n            public static String getVersion() {\n                return \"B A T T L E S H I P - Version 3.0 [January 23,2024]\";\n            }\n        \n            public BattleShipAPI(int numberOfGames, BattleShipBot bot) {\n                this.bot = bot;\n                this.numberOfGames = numberOfGames;\n                this.success = false;\n                this.boardSize = 10;\n                this.reset();\n                bot.initialize(this);\n            }\n        \n            public int[] run() {\n                long start = System.nanoTime();\n                this.totalShots = 0;\n                int[] gameScores = new int[this.numberOfGames];\n                this.success = false;\n        \n                try {\n                    for(int game = 0; game < this.numberOfGames; ++game) {\n                        this.reset();\n                        this.bot.initialize(this);\n        \n                        while(!this.allSunk()) {\n                            this.bot.fireShot();\n                        }\n        \n                        int gameShots = this.totalShotsTaken();\n                        gameScores[game] = gameShots;\n                        this.totalShots += gameShots;\n                        this.success = true;\n                    }\n                } catch (Exception var6) {\n                    System.out.println(\"RUNNING of Solution Failed \" + this.bot.getClass());\n                    System.out.println(var6.getMessage());\n                    var6.printStackTrace();\n                }\n        \n                this.timeRequired = (System.nanoTime() - start) / 1000000L;\n                return gameScores;\n            }\n        \n            public void reportResults() {\n                System.out.println(\"------------------------------------------------------------\");\n                System.out.printf(\"BattleShip 2 - Results for %s\\n\", this.bot.getClass().getName());\n                System.out.println(\"Author : \" + this.bot.getAuthors());\n                System.out.println(\"------------------------------------------------------------\");\n                if (this.success) {\n                    System.out.printf(\"The Average Score over %d games    = %.2f\\n\", this.numberOfGames, (double)this.totalShots / (double)this.numberOfGames);\n                    System.out.printf(\"Time required to complete %d games = %d ms\\n\", this.numberOfGames, this.timeRequired);\n                } else {\n                    System.out.println(\"Solution did not complete - Exception thrown in code\");\n                }\n        \n                System.out.println(\"------------------------------------------------------------\");\n            }\n        \n            private void reset() {\n                this.hits = new ArrayList();\n                this.misses = new ArrayList();\n                this.shipSizes = SHIP_SIZES;\n                this.board = new CellState[this.boardSize][this.boardSize];\n        \n                int i;\n                for(i = 0; i < this.boardSize; ++i) {\n                    for(int y = 0; y < this.boardSize; ++y) {\n                        this.board[i][y] = CellState.Empty;\n                    }\n                }\n        \n                this.ships = new ArrayList();\n        \n                for(i = 0; i < this.shipSizes.length; ++i) {\n                    Ship testShip = null;\n        \n                    do {\n                        Point location = new Point(this.random.nextInt(this.boardSize), this.random.nextInt(this.boardSize));\n                        ShipOrientation orientation = ShipOrientation.values()[this.random.nextInt(ShipOrientation.values().length)];\n                        testShip = new Ship(this.shipSizes[i], location, orientation);\n                        boolean placed = Ship.place(this.boardSize, testShip, this.ships);\n                        if (placed) {\n                        }\n                    } while(!testShip.getIsPlaced());\n        \n                    this.ships.add(testShip);\n                }\n        \n            }\n        \n            public boolean allSunk() {\n                int numberOfHitCells = 0;\n        \n                for(int y = 0; y < this.boardSize; ++y) {\n                    for(int x = 0; x < this.boardSize; ++x) {\n                        if (this.board[x][y] == CellState.Hit) {\n                            ++numberOfHitCells;\n                        }\n                    }\n                }\n        \n                return numberOfHitCells == this.totalShipLengths();\n            }\n        \n            public int totalShotsTaken() {\n                return this.hits.size() + this.misses.size();\n            }\n        \n            public int[] getShipSizes() {\n                return this.shipSizes;\n            }\n        \n            public boolean shoot(Point shot) {\n                boolean hit = this.shipAt(shot);\n                if (hit) {\n                    this.board[shot.x][shot.y] = CellState.Hit;\n                    this.hits.add(shot);\n                } else {\n                    this.board[shot.x][shot.y] = CellState.Miss;\n                    this.misses.add(shot);\n                }\n        \n                return this.shipAt(shot);\n            }\n        \n            public int numberOfShipsSunk() {\n                int num = 0;\n                Iterator var2 = this.ships.iterator();\n        \n                while(var2.hasNext()) {\n                    Ship s = (Ship)var2.next();\n                    int length = s.getLength();\n                    Point pos = s.getLocation();\n                    boolean sunk = true;\n                    int y;\n                    if (s.getOrientation() == ShipOrientation.Horizontal) {\n                        for(y = 0; y < length; ++y) {\n                            sunk &= this.board[pos.x + y][pos.y] == CellState.Hit;\n                        }\n                    } else {\n                        for(y = 0; y < length; ++y) {\n                            sunk &= this.board[pos.x][pos.y + y] == CellState.Hit;\n                        }\n                    }\n        \n                    if (sunk) {\n                        ++num;\n                    }\n                }\n        \n                return num;\n            }\n        \n            private boolean shipAt(Point p) {\n                Iterator var2 = this.ships.iterator();\n        \n                Ship s;\n                do {\n                    if (!var2.hasNext()) {\n                        return false;\n                    }\n        \n                    s = (Ship)var2.next();\n                } while(!s.isAt(p));\n        \n                return true;\n            }\n        \n            private void printBoard() {\n                System.out.print(\"\\n.  \");\n        \n                int y;\n                for(y = 0; y < this.boardSize; ++y) {\n                    System.out.printf(\"%2d \", y);\n                }\n        \n                for(y = 0; y < this.boardSize; ++y) {\n                    System.out.printf(\"\\n%2d \", y);\n        \n                    for(int x = 0; x < this.boardSize; ++x) {\n                        System.out.printf(\" %s \", this.board[x][y]);\n                    }\n                }\n        \n                System.out.println();\n            }\n        \n            private void debugPrintBoard() {\n                CellState[][] dboard = new CellState[this.boardSize][this.boardSize];\n        \n                int y;\n                int x;\n                for(y = 0; y < this.boardSize; ++y) {\n                    for(x = 0; x < this.boardSize; ++x) {\n                        if (this.shipAt(new Point(y, x))) {\n                            dboard[y][x] = CellState.Hit;\n                        } else {\n                            dboard[y][x] = CellState.Empty;\n                        }\n                    }\n                }\n        \n                System.out.print(\"\\n.  \");\n        \n                for(y = 0; y < this.boardSize; ++y) {\n                    System.out.printf(\"%2d \", y);\n                }\n        \n                for(y = 0; y < this.boardSize; ++y) {\n                    System.out.printf(\"\\n%2d \", y);\n        \n                    for(x = 0; x < this.boardSize; ++x) {\n                        System.out.printf(\" %s \", dboard[x][y]);\n                    }\n                }\n        \n                System.out.println();\n            }\n        \n            private int totalShipLengths() {\n                int length = 0;\n        \n                Ship s;\n                for(Iterator var2 = this.ships.iterator(); var2.hasNext(); length += s.getLength()) {\n                    s = (Ship)var2.next();\n                }\n        \n                return length;\n            }\n        \n            public static void main(String[] args) {\n                System.out.println(getVersion());\n            }\n        }`,\n    },\n    {\n        name: \"BattleShipBot.java\",\n        code: `package BattleShipAPI;\n\n        public interface BattleShipBot {\n            void initialize(BattleShipAPI var1);\n        \n            void fireShot();\n        \n            String getAuthors();\n        }`,\n    },\n    {\n        name: \"CellState.java\",\n        code: `package BattleShipAPI;\n\n        public enum CellState {\n            Empty,\n            Hit,\n            Miss;\n        \n            private CellState() {\n            }\n        \n            public String toString() {\n                switch (this) {\n                    case Empty:\n                        return \".\";\n                    case Hit:\n                        return \"X\";\n                    case Miss:\n                        return \"o\";\n                    default:\n                        return \"?\";\n                }\n            }\n        }`,\n    },\n    {\n        name: \"Ship.java\",\n        code: `package BattleShipAPI;\n\n        import java.awt.Point;\n        import java.util.ArrayList;\n        import java.util.Iterator;\n        \n        public final class Ship {\n            private boolean isPlaced = false;\n            private Point location;\n            private ShipOrientation orientation;\n            private int length;\n        \n            public Ship(int length, Point location, ShipOrientation orientation) {\n                if (length <= 0) {\n                    throw new IllegalArgumentException(\"Invalid length specified: must be >= 1 \");\n                } else {\n                    this.length = length;\n                    this.location = location;\n                    this.orientation = orientation;\n                }\n            }\n        \n            public boolean getIsPlaced() {\n                return this.isPlaced;\n            }\n        \n            public Point getLocation() {\n                return this.location;\n            }\n        \n            public ShipOrientation getOrientation() {\n                return this.orientation;\n            }\n        \n            public int getLength() {\n                return this.length;\n            }\n        \n            public static boolean place(int boardSize, Ship newShip, ArrayList<Ship> ships) {\n                newShip.isPlaced = false;\n                if (!newShip.isValid(boardSize)) {\n                    return false;\n                } else {\n                    if (ships != null) {\n                        Iterator var3 = ships.iterator();\n        \n                        label97:\n                        while(true) {\n                            while(true) {\n                                if (!var3.hasNext()) {\n                                    break label97;\n                                }\n        \n                                Ship ship = (Ship)var3.next();\n                                int x;\n                                int y;\n                                if (ship.orientation == ShipOrientation.Horizontal) {\n                                    x = ship.getLocation().y;\n        \n                                    for(y = ship.getLocation().x; y < ship.getLocation().x + ship.getLength(); ++y) {\n                                        if (y == ship.getLocation().x && y > 0 && newShip.isAt(new Point(y - 1, x))) {\n                                            return false;\n                                        }\n        \n                                        if (y == ship.getLocation().x + ship.getLength() - 1 && y < boardSize - 1 && newShip.isAt(new Point(y + 1, x))) {\n                                            return false;\n                                        }\n        \n                                        if (newShip.isAt(new Point(y, x)) || newShip.isAt(new Point(y, Math.max(0, x - 1))) || newShip.isAt(new Point(y, Math.min(boardSize - 1, x + 1)))) {\n                                            return false;\n                                        }\n                                    }\n                                } else if (ship.orientation == ShipOrientation.Vertical) {\n                                    x = ship.getLocation().x;\n        \n                                    for(y = ship.getLocation().y; y < ship.getLocation().y + ship.getLength(); ++y) {\n                                        if (y == ship.getLocation().y && y > 0 && newShip.isAt(new Point(x, y - 1))) {\n                                            return false;\n                                        }\n        \n                                        if (y == ship.getLocation().y + ship.getLength() - 1 && y < boardSize - 1 && newShip.isAt(new Point(x, y + 1))) {\n                                            return false;\n                                        }\n        \n                                        if (newShip.isAt(new Point(x, y)) || newShip.isAt(new Point(Math.max(0, x - 1), y)) || newShip.isAt(new Point(Math.min(boardSize - 1, x + 1), y))) {\n                                            return false;\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n        \n                    newShip.isPlaced = true;\n                    return true;\n                }\n            }\n        \n            public boolean isAt(Point p) {\n                if (this.getOrientation() == ShipOrientation.Horizontal) {\n                    return p.y == this.location.y && p.x >= this.location.x && p.x < this.location.x + this.length;\n                } else {\n                    return p.x == this.location.x && p.y >= this.location.y && p.y < this.location.y + this.length;\n                }\n            }\n        \n            public boolean isValid(int boardSize) {\n                if (this.location.x >= 0 && this.location.y >= 0) {\n                    if (this.orientation == ShipOrientation.Horizontal) {\n                        if (this.location.y >= boardSize || this.location.x + this.length > boardSize) {\n                            return false;\n                        }\n                    } else if (this.location.x >= boardSize || this.location.y + this.length > boardSize) {\n                        return false;\n                    }\n        \n                    return true;\n                } else {\n                    return false;\n                }\n            }\n        }`,\n    },\n    {\n        name: 'ShipOrientation.java',\n        code: `package BattleShipAPI;\n\n    public enum ShipOrientation {\n        Vertical,\n        Horizontal;\n    \n        private ShipOrientation() {\n        }\n    }`,\n    }\n];\n\n\n\nconst BattleShipBot = () => {\n    const navigate = useNavigate();\n\n    const handleBack = () => {\n        navigate(-1); // Navigate back to the previous page\n    };\n\n    return (\n        <Box sx={style.container}>\n            <Starfield />\n            <IconButton onClick={handleBack} sx={style.backButton}>\n                <ArrowBackIcon />\n            </IconButton>\n\n            <Grid container spacing={2}>\n                <ProjectOverview />\n                <YourApproach />\n                <TechnicalImplementation />\n                <Results />\n                <LearningsReflections />\n                <CodeAccessibility />\n            </Grid>\n\n            <LandscapeOverlay />\n        </Box>\n    );\n};\n\nconst ProjectOverview = () => {\n    return (\n        <Grid item xs={12}>\n            <Typography variant=\"h2\" sx={style.header}><br></br><br></br>\n                Battleship Strategy Bot\n            </Typography>\n            <Typography variant=\"body1\" sx={style.paragraph}>\n                The BattleShipBot, is an advanced Battleship game bot designed to play against an opponent with strategic precision.\n                This bot utilizes a unique combination of probabilistic and targeted strategies to enhance its gameplay, aiming to achieve the\n                lowest average number of shots across multiple games on a 10x10 grid.\n            </Typography>\n            <Typography variant=\"body1\" sx={style.paragraph}>\n                Objective: Minimize the number of shots required to sink all enemy ships across 10,000 games.\n            </Typography>\n        </Grid>\n    );\n}\n\nconst YourApproach = () => {\n    return (\n        <Grid item xs={12}>\n            <Typography variant=\"h4\" sx={style.featureHeading}>My Approach</Typography>\n            <Typography variant=\"body1\" sx={style.paragraph}>\n                BattleShipBot implements a hybrid strategy, integrating both probabilistic and targeted approaches.\n                It leverages historical data to make educated guesses in the early game and switches to a\n                more focused approach once a ship is hit, targeting specific areas to effectively sink ships.\n            </Typography>\n            <Typography variant=\"body1\" sx={style.paragraph}>\n                The bot employs arrays, sets, maps, and priority queues to manage the game state, track ship placements,\n                and calculate shot probabilities. This selection of data structures ensures efficient data management\n                and optimal decision-making during gameplay.\n            </Typography>\n        </Grid>\n    );\n}\n\nconst TechnicalImplementation = () => {\n    return (\n        <Grid item xs={12}>\n            <Typography variant=\"h4\" sx={style.featureHeading}>Technical Implementation</Typography>\n            <Typography variant=\"body1\" sx={style.paragraph}>\n                One challenge was efficiently managing the probabilistic calculations for shot selection.\n                This was solved by using a priority queue to rank cells based on their likelihood of containing a ship,\n                significantly optimizing the shot selection process.\n                <div>\n                    {filesData.map((fileData) => (\n                        <FileTreeItem key={fileData.name} fileName={fileData.name} codeSnippet={fileData.code} />\n                    ))}\n                </div>\n            </Typography>\n        </Grid>\n    );\n}\n\nconst Results = () => {\n    return (\n        <Grid item xs={12}>\n            <Typography variant=\"h4\" sx={style.featureHeading}>Results</Typography>\n            <Typography variant=\"body1\" sx={style.paragraph}>\n                The BattleShip bot achieved an impressive average shot count well below the goal target, showcasing its\n                effectiveness in strategically playing Battleship. The precise combination of algorithms and data\n                structures played a pivotal role in this achievement.\n            </Typography>\n        </Grid>\n    );\n}\n\nconst LearningsReflections = () => {\n    return (\n        <Grid item xs={12}>\n            <Typography variant=\"h4\" sx={style.featureHeading}>Learnings and Reflections</Typography>\n            <Typography variant=\"body1\" sx={style.paragraph}>\n                This project enhanced my understanding of algorithm efficiency and data structure selection.\n                The importance of choosing the right strategy based on game context was a key takeaway,\n                offering insights into adaptive algorithm design.\n            </Typography>\n        </Grid>\n    );\n}\n\nconst CodeAccessibility = () => {\n    return (\n        <Grid item xs={12}>\n            <Typography variant=\"h4\" sx={style.featureHeading}>Code Accessibility</Typography>\n            <Typography variant=\"body1\" sx={style.paragraph}>\n                Access the complete code for this project via the downloadable ZIP file. This comprehensive package contains all the necessary files and documentation to explore and understand the BattleShip Bot in detail.\n            </Typography>\n            <Button\n                variant=\"contained\"\n                color=\"primary\"\n                href=\"https://drive.google.com/uc?export=download&id=1lzJLerHY6IB5U9nSyc3LxcWD01hFUd46\"\n                startIcon={<GetAppIcon />}\n                sx={{ marginTop: '1rem' }}\n                download=\"BattleShip-main.zip\"\n            >\n                Download Full Code\n            </Button>\n\n        </Grid>\n    );\n};\n\nexport default BattleShipBot;\n"],"mappings":";;AAAA,OAAOA,KAAK,MAAM,OAAO;AACzB,SAASC,GAAG,EAAEC,UAAU,EAAEC,UAAU,EAAEC,IAAI,EAAEC,MAAM,QAAQ,eAAe;AACzE,OAAOC,aAAa,MAAM,+BAA+B;AACzD,OAAOC,gBAAgB,MAAM,mCAAmC;AAChE,SAASC,WAAW,QAAQ,kBAAkB;AAC9C,OAAOC,SAAS,MAAM,4BAA4B;AAClD,OAAOC,YAAY,MAAM,+BAA+B;AACxD,OAAOC,UAAU,MAAM,4BAA4B;AAAC,SAAAC,MAAA,IAAAC,OAAA;AAEpD,MAAMC,KAAK,GAAG;EACVC,SAAS,EAAE;IACPC,OAAO,EAAE,MAAM;IACfC,eAAe,EAAE,oBAAoB;IACrCC,KAAK,EAAE,SAAS;IAChBC,SAAS,EAAE,OAAO;IAClBC,OAAO,EAAE,MAAM;IACfC,aAAa,EAAE,QAAQ;IACvBC,UAAU,EAAE,QAAQ;IACpBC,cAAc,EAAE,QAAQ;IACxBC,QAAQ,EAAE,OAAO;IACjBC,UAAU,EAAE,MAAM;IAClBC,WAAW,EAAE,MAAM;IACnBC,YAAY,EAAE,MAAM;IACpB,2BAA2B,EAAE;MACzBH,QAAQ,EAAE,MAAM;MAChBR,OAAO,EAAE;IACb;EACJ,CAAC;EACDY,MAAM,EAAE;IACJC,YAAY,EAAE,MAAM;IACpBC,SAAS,EAAE,QAAQ;IACnBC,QAAQ,EAAE,MAAM;IAChBb,KAAK,EAAE;EACX,CAAC;EACDc,SAAS,EAAE;IACPH,YAAY,EAAE,MAAM;IACpBC,SAAS,EAAE,MAAM;IACjBG,UAAU,EAAE;EAChB,CAAC;EACDC,UAAU,EAAE;IACRC,SAAS,EAAE,MAAM;IACjBL,SAAS,EAAE;EACf,CAAC;EACDM,cAAc,EAAE;IACZP,YAAY,EAAE,MAAM;IACpBE,QAAQ,EAAE,QAAQ;IAClBM,UAAU,EAAE,MAAM;IAClBnB,KAAK,EAAE;EACX,CAAC;EACDoB,UAAU,EAAE;IACRC,QAAQ,EAAE,UAAU;IACpBC,GAAG,EAAE,MAAM;IACXC,IAAI,EAAE,MAAM;IACZC,MAAM,EAAE;EACZ,CAAC;EACDC,WAAW,EAAE;IACT1B,eAAe,EAAE,MAAM;IACvBC,KAAK,EAAE,MAAM;IACbF,OAAO,EAAE,MAAM;IACfW,YAAY,EAAE,KAAK;IACnBI,QAAQ,EAAE;EACd,CAAC;EACDa,IAAI,EAAE;IACF1B,KAAK,EAAE,SAAS;IAChB2B,cAAc,EAAE,MAAM;IACtB,SAAS,EAAE;MACPA,cAAc,EAAE;IACpB;EACJ;AACJ,CAAC;AAED,MAAMC,SAAS,GAAG,CACd;EACIC,IAAI,EAAE,YAAY;EAClBC,IAAI,EAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACI,CAAC,EACD;EACID,IAAI,EAAE,cAAc;EACpBC,IAAI,EAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACI,CAAC,EACD;EACID,IAAI,EAAE,oBAAoB;EAC1BC,IAAI,EAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACI,CAAC,EACD;EACID,IAAI,EAAE,oBAAoB;EAC1BC,IAAI,EAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACI,CAAC,EACD;EACID,IAAI,EAAE,gBAAgB;EACtBC,IAAI,EAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACI,CAAC,EACD;EACID,IAAI,EAAE,WAAW;EACjBC,IAAI,EAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACI,CAAC,EACD;EACID,IAAI,EAAE,sBAAsB;EAC5BC,IAAI,EAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACI,CAAC,CACJ;AAID,MAAMC,aAAa,GAAGA,CAAA,KAAM;EAAAC,EAAA;EACxB,MAAMC,QAAQ,GAAG3C,WAAW,CAAC,CAAC;EAE9B,MAAM4C,UAAU,GAAGA,CAAA,KAAM;IACrBD,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;EAClB,CAAC;EAED,oBACItC,OAAA,CAACZ,GAAG;IAACoD,EAAE,EAAEvC,KAAK,CAACC,SAAU;IAAAuC,QAAA,gBACrBzC,OAAA,CAACJ,SAAS;MAAA8C,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OAAE,CAAC,eACb7C,OAAA,CAACV,UAAU;MAACwD,OAAO,EAAEP,UAAW;MAACC,EAAE,EAAEvC,KAAK,CAACwB,UAAW;MAAAgB,QAAA,eAClDzC,OAAA,CAACP,aAAa;QAAAiD,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,OAAE;IAAC;MAAAH,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OACT,CAAC,eAEb7C,OAAA,CAACT,IAAI;MAACW,SAAS;MAAC6C,OAAO,EAAE,CAAE;MAAAN,QAAA,gBACvBzC,OAAA,CAACgD,eAAe;QAAAN,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,OAAE,CAAC,eACnB7C,OAAA,CAACiD,YAAY;QAAAP,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,OAAE,CAAC,eAChB7C,OAAA,CAACkD,uBAAuB;QAAAR,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,OAAE,CAAC,eAC3B7C,OAAA,CAACmD,OAAO;QAAAT,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,OAAE,CAAC,eACX7C,OAAA,CAACoD,oBAAoB;QAAAV,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,OAAE,CAAC,eACxB7C,OAAA,CAACqD,iBAAiB;QAAAX,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,OAAE,CAAC;IAAA;MAAAH,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OACnB,CAAC,eAEP7C,OAAA,CAACN,gBAAgB;MAAAgD,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OAAE,CAAC;EAAA;IAAAH,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OACnB,CAAC;AAEd,CAAC;AAACR,EAAA,CA1BID,aAAa;EAAA,QACEzC,WAAW;AAAA;AAAA2D,EAAA,GAD1BlB,aAAa;AA4BnB,MAAMY,eAAe,GAAGA,CAAA,KAAM;EAC1B,oBACIhD,OAAA,CAACT,IAAI;IAACgE,IAAI;IAACC,EAAE,EAAE,EAAG;IAAAf,QAAA,gBACdzC,OAAA,CAACX,UAAU;MAACoE,OAAO,EAAC,IAAI;MAACjB,EAAE,EAAEvC,KAAK,CAACc,MAAO;MAAA0B,QAAA,gBAACzC,OAAA;QAAA0C,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,OAAQ,CAAC,eAAA7C,OAAA;QAAA0C,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,OAAQ,CAAC,2BAE7D;IAAA;MAAAH,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OAAY,CAAC,eACb7C,OAAA,CAACX,UAAU;MAACoE,OAAO,EAAC,OAAO;MAACjB,EAAE,EAAEvC,KAAK,CAACkB,SAAU;MAAAsB,QAAA,EAAC;IAIjD;MAAAC,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OAAY,CAAC,eACb7C,OAAA,CAACX,UAAU;MAACoE,OAAO,EAAC,OAAO;MAACjB,EAAE,EAAEvC,KAAK,CAACkB,SAAU;MAAAsB,QAAA,EAAC;IAEjD;MAAAC,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OAAY,CAAC;EAAA;IAAAH,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OACX,CAAC;AAEf,CAAC;AAAAa,GAAA,GAhBKV,eAAe;AAkBrB,MAAMC,YAAY,GAAGA,CAAA,KAAM;EACvB,oBACIjD,OAAA,CAACT,IAAI;IAACgE,IAAI;IAACC,EAAE,EAAE,EAAG;IAAAf,QAAA,gBACdzC,OAAA,CAACX,UAAU;MAACoE,OAAO,EAAC,IAAI;MAACjB,EAAE,EAAEvC,KAAK,CAACsB,cAAe;MAAAkB,QAAA,EAAC;IAAW;MAAAC,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OAAY,CAAC,eAC3E7C,OAAA,CAACX,UAAU;MAACoE,OAAO,EAAC,OAAO;MAACjB,EAAE,EAAEvC,KAAK,CAACkB,SAAU;MAAAsB,QAAA,EAAC;IAIjD;MAAAC,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OAAY,CAAC,eACb7C,OAAA,CAACX,UAAU;MAACoE,OAAO,EAAC,OAAO;MAACjB,EAAE,EAAEvC,KAAK,CAACkB,SAAU;MAAAsB,QAAA,EAAC;IAIjD;MAAAC,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OAAY,CAAC;EAAA;IAAAH,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OACX,CAAC;AAEf,CAAC;AAAAc,GAAA,GAhBKV,YAAY;AAkBlB,MAAMC,uBAAuB,GAAGA,CAAA,KAAM;EAClC,oBACIlD,OAAA,CAACT,IAAI;IAACgE,IAAI;IAACC,EAAE,EAAE,EAAG;IAAAf,QAAA,gBACdzC,OAAA,CAACX,UAAU;MAACoE,OAAO,EAAC,IAAI;MAACjB,EAAE,EAAEvC,KAAK,CAACsB,cAAe;MAAAkB,QAAA,EAAC;IAAwB;MAAAC,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OAAY,CAAC,eACxF7C,OAAA,CAACX,UAAU;MAACoE,OAAO,EAAC,OAAO;MAACjB,EAAE,EAAEvC,KAAK,CAACkB,SAAU;MAAAsB,QAAA,GAAC,wPAI7C,eAAAzC,OAAA;QAAAyC,QAAA,EACKR,SAAS,CAAC2B,GAAG,CAAEC,QAAQ,iBACpB7D,OAAA,CAACH,YAAY;UAAqB6C,QAAQ,EAAEmB,QAAQ,CAAC3B,IAAK;UAACJ,WAAW,EAAE+B,QAAQ,CAAC1B;QAAK,GAAnE0B,QAAQ,CAAC3B,IAAI;UAAAQ,QAAA,EAAAC,YAAA;UAAAC,UAAA;UAAAC,YAAA;QAAA,OAAwD,CAC3F;MAAC;QAAAH,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,OACD,CAAC;IAAA;MAAAH,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OACE,CAAC;EAAA;IAAAH,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OACX,CAAC;AAEf,CAAC;AAAAiB,GAAA,GAhBKZ,uBAAuB;AAkB7B,MAAMC,OAAO,GAAGA,CAAA,KAAM;EAClB,oBACInD,OAAA,CAACT,IAAI;IAACgE,IAAI;IAACC,EAAE,EAAE,EAAG;IAAAf,QAAA,gBACdzC,OAAA,CAACX,UAAU;MAACoE,OAAO,EAAC,IAAI;MAACjB,EAAE,EAAEvC,KAAK,CAACsB,cAAe;MAAAkB,QAAA,EAAC;IAAO;MAAAC,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OAAY,CAAC,eACvE7C,OAAA,CAACX,UAAU;MAACoE,OAAO,EAAC,OAAO;MAACjB,EAAE,EAAEvC,KAAK,CAACkB,SAAU;MAAAsB,QAAA,EAAC;IAIjD;MAAAC,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OAAY,CAAC;EAAA;IAAAH,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OACX,CAAC;AAEf,CAAC;AAAAkB,GAAA,GAXKZ,OAAO;AAab,MAAMC,oBAAoB,GAAGA,CAAA,KAAM;EAC/B,oBACIpD,OAAA,CAACT,IAAI;IAACgE,IAAI;IAACC,EAAE,EAAE,EAAG;IAAAf,QAAA,gBACdzC,OAAA,CAACX,UAAU;MAACoE,OAAO,EAAC,IAAI;MAACjB,EAAE,EAAEvC,KAAK,CAACsB,cAAe;MAAAkB,QAAA,EAAC;IAAyB;MAAAC,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OAAY,CAAC,eACzF7C,OAAA,CAACX,UAAU;MAACoE,OAAO,EAAC,OAAO;MAACjB,EAAE,EAAEvC,KAAK,CAACkB,SAAU;MAAAsB,QAAA,EAAC;IAIjD;MAAAC,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OAAY,CAAC;EAAA;IAAAH,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OACX,CAAC;AAEf,CAAC;AAAAmB,GAAA,GAXKZ,oBAAoB;AAa1B,MAAMC,iBAAiB,GAAGA,CAAA,KAAM;EAC5B,oBACIrD,OAAA,CAACT,IAAI;IAACgE,IAAI;IAACC,EAAE,EAAE,EAAG;IAAAf,QAAA,gBACdzC,OAAA,CAACX,UAAU;MAACoE,OAAO,EAAC,IAAI;MAACjB,EAAE,EAAEvC,KAAK,CAACsB,cAAe;MAAAkB,QAAA,EAAC;IAAkB;MAAAC,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OAAY,CAAC,eAClF7C,OAAA,CAACX,UAAU;MAACoE,OAAO,EAAC,OAAO;MAACjB,EAAE,EAAEvC,KAAK,CAACkB,SAAU;MAAAsB,QAAA,EAAC;IAEjD;MAAAC,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OAAY,CAAC,eACb7C,OAAA,CAACR,MAAM;MACHiE,OAAO,EAAC,WAAW;MACnBpD,KAAK,EAAC,SAAS;MACf4D,IAAI,EAAC,kFAAkF;MACvFC,SAAS,eAAElE,OAAA,CAACF,UAAU;QAAA4C,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,OAAE,CAAE;MAC1BL,EAAE,EAAE;QAAElB,SAAS,EAAE;MAAO,CAAE;MAC1B6C,QAAQ,EAAC,qBAAqB;MAAA1B,QAAA,EACjC;IAED;MAAAC,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OAAQ,CAAC;EAAA;IAAAH,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OAEP,CAAC;AAEf,CAAC;AAACuB,GAAA,GApBIf,iBAAiB;AAsBvB,eAAejB,aAAa;AAAC,IAAAkB,EAAA,EAAAI,GAAA,EAAAC,GAAA,EAAAG,GAAA,EAAAC,GAAA,EAAAC,GAAA,EAAAI,GAAA;AAAAC,YAAA,CAAAf,EAAA;AAAAe,YAAA,CAAAX,GAAA;AAAAW,YAAA,CAAAV,GAAA;AAAAU,YAAA,CAAAP,GAAA;AAAAO,YAAA,CAAAN,GAAA;AAAAM,YAAA,CAAAL,GAAA;AAAAK,YAAA,CAAAD,GAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}